{
  "hash": "0201ef6e5298b781d9f6a8193f6ff01f",
  "result": {
    "markdown": "---\ntitle: 시계열 데이터\nauthor: Gabriel Yang\n---\n\n시계열 데이터는 일정 시간간격을 측정된 정보한 데이터입니다. 시계열 데이터는 시간의 흐름에 따라서 테이터가 갖는\n특징을 확인하기 위해서 생성되며 금융 정보나 생체 정보등의 특징을 저장하는 경우가 많습니다.\n\nPandas는 시계열 데이터를 관리하기 위한 많은 기능을 제공합니다.  데이터의 추세, 주기성 등을 파악할 수 있고\n필요한 경우 예측 모델링을 할 수 있습니다. 그리고 원하는 형태의 시간을 표시할 수 있도록 DatetimeIndex, Timestamp, Teimdelta등\n다양한 함수를 지원하고 있습니다.\n\n\n## 시간 데이터형\n\n시계열 데이터를 이해하기 위해서 데이터를 구성하는 날짜를 어떻게 지정하는 지 이해해야 합니다.\n파이썬은 날짜와 시간을 나타내는 `datetime`클래스를 제공합니다. 그리고 Pandas는 datetime객체를 Timestamp 객체로 변화시켜 사용합니다.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfrom datetime import datetime\nnew_year = datetime(2023, 1, 1, 0, 0)\nnew_year\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ndatetime.datetime(2023, 1, 1, 0, 0)\n```\n:::\n:::\n\n\n`datetime`객체를 이용하여 2023년 1월 1일 0시 0분을 나타내는 객체를 생성하였습니다. 이제 Timestamp를 이용하여\n특정 시점을 표현합니다.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport pandas as pd\ntime_start = pd.Timestamp('2002-5-5 13:00')\ntime_start\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nTimestamp('2002-05-05 13:00:00')\n```\n:::\n:::\n\n\n이제 Pandas의 시계열 데이터의 특정시점을 지정하기 위해서 Timestamp 객체를 생성할 수 있습니다. 하지만 시간 정보를\n전달 받는 대부분의 라이브러리는 내부적으로 Timestamp객체로 만들어 데이터를 처리하기 때문에 날짜 및 시간을 표시하는 문자열을 전달 받습니다.\n\n만약 이와 같이 구성하지 않고 생각해보면 매번 Timestamp나 datetime 클래스로 시간 정보를 변경해서 전달 해야 했다면 매우 불편했을 것 같습니다.\n\n시계열 데이터는 데이터의 인덱스로 시간 정보를 사용하는 경우가 대부분입니다. Pandas에서는 Timestamp 데이터로 정의된 인덱스인\n`DatetimeIndex`객체를 사용합니다. 시계열 데이터로 데이터 프레임을 생성하고 이 데이터 프레임 index가 어떤 데이터 형인지 알아봅니다.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndates = pd.Series([10, 20], [pd.Timestamp('2023-1-1'), pd.Timestamp('2023-1-2')])\nprint(type(dates.index))\ndisplay(dates)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'pandas.core.indexes.datetimes.DatetimeIndex'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```\n2023-01-01    10\n2023-01-02    20\ndtype: int64\n```\n:::\n:::\n\n\n위의 코드에서 `dates`라는 이름으로 pandas series데이터를 생성했습니다. 데이터와 함께 index로 Timestamp정보가 전달됩니다.\n`dates` series 데이터에 전달된 Timestamp는 인덱스로 사용되면서 데이터형은 `DatetimeIndex`로 설정되었습니다.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndf = pd.DataFrame({'data': [10, 20]},\n                    index = pd.to_datetime(['2023-1-1', '2023-1-2']))\nprint(type(df.index))\ndisplay(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'pandas.core.indexes.datetimes.DatetimeIndex'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>data</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>2023-01-01</th>\n      <td>10</td>\n    </tr>\n    <tr>\n      <th>2023-01-02</th>\n      <td>20</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n위의 코드는 df 데이터 프레임 생성 시 index정보를 `to_datetime()`함수를 이용하여 Timestamp로 변환하고\n이를 index로 전달했습니다. 데이터 프레임의 index는 이전 예제와 같이 `DatetimeIndex`로 표시됩니다.\n\n::: callout-tip\n하지만 매번 Timestamp객체를 만들어 전달하는 것을 코드의 가독성을 낮추는 문제가 있습니다.\n`to_dateteime`함수는 Pandas는 Timestamp로 전달될 수 있는 문자열을 Timestamp로 변환할 수 있기 때문에\n좀 더 효율적으로 `DatetimeIndex`를 생성할 수 있습니다.\n:::\n\n\n\n\n\n\n\n\n\n\n\n## 시간 간격 표현방법\n\n### Timedelta\nTimedelta 클래스는 시간간격을 표시하기 위해 사용됩니다. 두 날짜 사이의 차이를 계산하거나\n간격을 계산하기 위해서 사용됩니다. Timedelta를 사용하기 위해서는 datatime 패키지에서 `Timedelta`를 import해야 합니다.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nimport pandas as pd\nfrom datetime import datetime, timedelta\nnow = datetime.now()\nbefore_7days = now - timedelta(days=7)\ndisplay(before_7days)\n```\n\n::: {.cell-output .cell-output-display}\n```\ndatetime.datetime(2023, 11, 6, 23, 53, 8, 632763)\n```\n:::\n:::\n\n\n예를 들어 시계열 데이터의 현재시점에서 7일전 데이터와의 차이를 확인하기 위해서는 현재 시점에서\n원하는 날짜 차이를 빼야 합니다. timedelta를 사용하여 현재 시간에서 7일전을 계산한 결과가 출력되었습니다.\n\n### DateOffset\n\nDateOffset은 정기적인 증가 또는 감소를 표현하기 위한 시간적 크기를 표현합니다.\n일정 시점에서 자신이 원하는 시간 간격만큼 더하거나 빼는 수학적 연산을 DateOffset을 이용하여 수행합니다.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndate = pd.Timestamp('2023-01-01')\noffset_3days = pd.DateOffset(days = 3)\noffset_3hours = pd.DateOffset(hours = 3)\ndisplay(date + offset_3days)\ndisplay(date + offset_3hours)\n```\n\n::: {.cell-output .cell-output-display}\n```\nTimestamp('2023-01-04 00:00:00')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```\nTimestamp('2023-01-01 03:00:00')\n```\n:::\n:::\n\n\n2023년 1월 1일을 나타내는 `date`에 3일과 3시간 간격의 `DateOffset` 객체를 더해\n지정한 간격의 날짜 정보를 얻을 수 있습니다.\n\n\n\n\n\n\n\n\n\n## 시간 반복 시계열 생성방법\n\n### Range\n\nRange class는 일정 시간 간격으로 시계열 데이터를 만들어야하는 경우 사용됩니다.\n년도, 분기, 월 등 다양한 시간간격을 나타낼 수 있으며 이를 이용하여 일정한 간격의\n시계열 데이터를 처리하는 경우에 사용할 수 있습니다.\n\n예를 들어 특정한 시작날짜와 종료날짜 사이의 기간을 주단위로 시간간격으로 정보를 확인해야하는 경우\n사용될 수 있습니다.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range('2023-1-1', '2023-5-1', freq = 'W')\ndf = pd.DataFrame({'date' : dates,\n                   'value' : range(len(dates))})\ndisplay(dates)\ndisplay(df.head())\n```\n\n::: {.cell-output .cell-output-display}\n```\nDatetimeIndex(['2023-01-01', '2023-01-08', '2023-01-15', '2023-01-22',\n               '2023-01-29', '2023-02-05', '2023-02-12', '2023-02-19',\n               '2023-02-26', '2023-03-05', '2023-03-12', '2023-03-19',\n               '2023-03-26', '2023-04-02', '2023-04-09', '2023-04-16',\n               '2023-04-23', '2023-04-30'],\n              dtype='datetime64[ns]', freq='W-SUN')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>date</th>\n      <th>value</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2023-01-01</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2023-01-08</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2023-01-15</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>2023-01-22</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>2023-01-29</td>\n      <td>4</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n`dates`는 `date_range()`함수에 전달된 시작시점과 종료시점 사이를 `freq`로 전달된 간격만큼 떨어진\n시간 정보를 생성했습니다. freq로 전달될 수 있는 주요 offset정보는 아래와 같습니다.\n자세한 내용은 [Pandas API 문서](https://pandas.pydata.org/docs/user_guide/timeseries.html#timeseries-offset-aliases)에서 확인 합니다.\n\n| Alias | Description              |\n| ----  | :----------------------: |\n|   B   | business day frequency   |\n|   BM  | business month end frequency |\n|   MS  | month start frequency |\n|  Q    | quarter end frequency |\n|  W-MON | weekly frequency (Mondays) |\n\n`W-MON`은 고정 오프셋으로 특정 날짜를 기준으로하는 빈도가 필요할 때 사용합니다. 위의 예제의\n기간 중 매주 월요일을 간격으로 날짜를 생성하는 예제를 확인합니다.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range('2023-1-1', '2023-5-1', freq = 'W-MON')\ndf = pd.DataFrame({'date' : dates,\n                   'value' : range(len(dates))})\ndisplay(df.head())\n```\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>date</th>\n      <th>value</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2023-01-02</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2023-01-09</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2023-01-16</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>2023-01-23</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>2023-01-30</td>\n      <td>4</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n생성된 데이터 프레임의 처음 날짜는 2023년 1월 1일이 아니고 해당 기간 중 첫 번째 월요일인\n2023년 1월 2일로 날짜가 생성되었습니다.\n\n### Period {#sec-TimeSeries-Period}\n\n일정 시점에서 한달 간격으로 수행하는 작업이 있는 경우 `Period`를 사용할 수 있습니다.\nPeriod는 Timestamp와 DateOffset으로 생성한는 시간 데이터를 더 효율적으로 관리할 수 있도록 합니다.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nperiods = pd.Period('2023-1-1', freq='M')\ndisplay(periods)\ndisplay(periods+1)\n```\n\n::: {.cell-output .cell-output-display}\n```\nPeriod('2023-01', 'M')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```\nPeriod('2023-02', 'M')\n```\n:::\n:::\n\n\n## 시계열 데이터 만들기\n\n다양한 시계열 데이터를 만들면서 Pandas에서 제공하는 시계열 데이터 생성 기능을 배워봅니다.\n\n### 특정 빈도의 시계열 생성\nPandas에서 제공하는 `to_datetime()'과 `date_range()` 함수를 이용해서 시계열 데이터를 만들어 봅니다.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nindex = pd.to_datetime(['2023-1-1', '2023-2-28', '2023-3-31', '2023-4-30'])\ndata = range(len(index))\ndf = pd.DataFrame({'data': data},\n                    index = index)\nprint(type(df.index))\ndisplay(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'pandas.core.indexes.datetimes.DatetimeIndex'>\n```\n:::\n\n::: {#fig-timeseries-dataframe-datetime .cell-output .cell-output-display}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>data</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>2023-01-01</th>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>2023-02-28</th>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>2023-03-31</th>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>2023-04-30</th>\n      <td>3</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n\n데이터프레임 생성, to_datetime()\n:::\n:::\n\n\n위의 예제에서는 `to_datetime()`함수로 일정 시간 정보를 데이터 프레임의 index로 전달하여\n데이터 프레임을 생성합니다. 데이터 프레임의 index는 `DateTimeIndex`로 표시되었습니다.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nindex = pd.date_range('2023-1-1', '2023-5-1', freq = 'M')\ndata = range(len(index))\ndf = pd.DataFrame({'data' : data},\n                   index = index)\ndisplay(df)\n```\n\n::: {#fig-timeseries-dataframe-daterange .cell-output .cell-output-display}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>data</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>2023-01-31</th>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>2023-02-28</th>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>2023-03-31</th>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>2023-04-30</th>\n      <td>3</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n\n데이터프레임 생성, date_range()\n:::\n:::\n\n\n@sec-TimeSeries-Period 에서 사용한 `date_range()`함수를 이용하면\n@fig-timeseries-dataframe-datetime 와 같이 `to_datatime()`함수 이용한 시간 정보가 동일한 간격이라면\n@fig-timeseries-dataframe-daterange 처럼 `date_range()`함수를 이용해 다시 간략하게 표현할 수 있습니다.\n\n",
    "supporting": [
      "time_series_basic_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}