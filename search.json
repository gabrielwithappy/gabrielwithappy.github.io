[
  {
    "objectID": "books.html",
    "href": "books.html",
    "title": "Books",
    "section": "",
    "text": "온라인 책들을 정리합니다."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Public Book",
    "section": "",
    "text": "온라인 책장입니다. 공부한 내용을 정리하고 차근차근 모아 책으로 만듭니다. 추가하고 싶은 책이 있다면 블로그에 하나씩 글을 모으는 것으로 시작합니다. 느리게 작지만 꾸준히 글쓰기를 연습합니다."
  },
  {
    "objectID": "docs/slideshelf/quarto-introduction/index.html#quart가-뭐죠",
    "href": "docs/slideshelf/quarto-introduction/index.html#quart가-뭐죠",
    "title": "Quarto 맛보기",
    "section": "Quart가 뭐죠?",
    "text": "Quart가 뭐죠?\n\n오픈소스 과학, 기술 출판 시스템\n주피터 노트북 또는 마크다운을 이용한 문서 작성\n웹페이지, 블로그, 프리젠테이션 작성\n예제\n\n(website) publickrbook.com\n(website) deep learning glossary\n(slides) Quarto 맛보기"
  },
  {
    "objectID": "docs/slideshelf/quarto-introduction/index.html#설치하기",
    "href": "docs/slideshelf/quarto-introduction/index.html#설치하기",
    "title": "Quarto 맛보기",
    "section": "설치하기",
    "text": "설치하기\n\nQuarto 공식홈페이지에서 프로그램 설치\n다양한 에디터를 지원하고 있음\n\nVSCODE\nJupyter Notebook\nR\nNewvim"
  },
  {
    "objectID": "docs/slideshelf/quarto-introduction/index.html#프로젝트-생성하기",
    "href": "docs/slideshelf/quarto-introduction/index.html#프로젝트-생성하기",
    "title": "Quarto 맛보기",
    "section": "프로젝트 생성하기",
    "text": "프로젝트 생성하기\n\n프로젝트 생성\n\nquarto create project\n ? Type\n ❯ default\n   website\n   blog\n   book\n\n프로젝트 타입설정\n\nwebsite: 다양한 문서그룹을 통합적을 관리 가능\nblog: 블로그는 게시물 모음과 게시물을 나열하는 탐색 페이지로 구성\nbook: 온라인북에 특화된 유형의 Quarto 웹사이트"
  },
  {
    "objectID": "docs/slideshelf/quarto-introduction/index.html#metadata",
    "href": "docs/slideshelf/quarto-introduction/index.html#metadata",
    "title": "Quarto 맛보기",
    "section": "Metadata",
    "text": "Metadata\n\n_quarto.yml: 모든 Quarto프로젝트에 있으며 프로젝트 수준으로 정의가 필요한 옵션 설정\n\nproject:\n  type: website\n\nwebsite:\n  title: \"Public KR Book\"\n  page-footer:\n    center: \"welcome\"\n  navbar:\n    left:\n      - href: index.qmd\n        text: Home\n\n  sidebar:\n      collapse-level: 1\n      contents:\n        - docs/bookshelf/hf-examples/index.qmd\n        - section: \"Task별 예제\"\n          contents:\n            - section: \"Video\"\n\nNavbarSideBarPage Footer\n\n\nnabvar: 웹사이트 상단 네비게이션 바\n\n\nside-bar: 왼쪽 사이드 바\n\n\npage footer: 웹사이트 footer 정보"
  },
  {
    "objectID": "docs/slideshelf/quarto-introduction/index.html#웹사이트-렌더링-미리보기",
    "href": "docs/slideshelf/quarto-introduction/index.html#웹사이트-렌더링-미리보기",
    "title": "Quarto 맛보기",
    "section": "웹사이트 렌더링 / 미리보기",
    "text": "웹사이트 렌더링 / 미리보기\n\n렌터링 대상 파일은 Quarto에서 인식가능한 모든 파일\n\n.qmd, .ipynb, .md, .Rmd\n\n웹사이트를 만들기 위한 html 코드를 생성\n생성된 html 파일들은 _site 디렉토리에 저장됨\n렌더링 코드\n\nquarto render\n\n다양한 방식으로 렌더링 가능\n\nquarto render document.qmd --to pdf\nquarto render document.qmd --to docx\n\n웹사이트 미리보기\n\nquarto preview"
  },
  {
    "objectID": "docs/slideshelf/quarto-introduction/index.html#번역의-어려움-1",
    "href": "docs/slideshelf/quarto-introduction/index.html#번역의-어려움-1",
    "title": "Quarto 맛보기",
    "section": "번역의 어려움 1",
    "text": "번역의 어려움 1\n\n일관성 있게 용어를 사용하기가 어려움\n\n번역하는 사람이 여러 명이기 때문에 동일한 용어를 다르게 번역하는 경우가 발생함\n한국어 문장 형식이 서로 다름.\n\n~한다로 사용? 아니면 ~합니다로 사용?\n\n\n팀 내부에서 간단한 style guide를 정하면 좋다.\n\n하지만 너무 복잡하면 찾기 어려워 결국 사용 못함!\n컨센서스와 쉽게 확인할 수 있는 정도가 좋음."
  },
  {
    "objectID": "docs/slideshelf/quarto-introduction/index.html#번역의-어려움-2",
    "href": "docs/slideshelf/quarto-introduction/index.html#번역의-어려움-2",
    "title": "Quarto 맛보기",
    "section": "번역의 어려움 2",
    "text": "번역의 어려움 2\n\n번역 리뷰는 어떻게 진행하지?\n\n얼마나 자세하게 확인해야하나?\n하다보면 계속 고칠 것이 나와서 번역이 완료가 안됨! ㅠ_ㅠ\n\n번역완료에 대한 기준 (시간, 리뷰어 수를 정하자!!\n\n\n\n번역을 하다보니 문서 자체에 대한 이해가 부족한 것 같다.\n\n번역은 다 했는데 막상 다시보니 문서내용을 이해를 못했다.\n번역 작업의 목적?\n\n문서를 이해하고 배우기 위한 것이 목적인가?\n아니면 번역 skill을 높이는 것이 목적인가?\n\n머지가 되면 자기 문서를 발표해보자."
  },
  {
    "objectID": "docs/slideshelf/quarto-introduction/index.html#번역의-어려움-3",
    "href": "docs/slideshelf/quarto-introduction/index.html#번역의-어려움-3",
    "title": "Quarto 맛보기",
    "section": "번역의 어려움 3",
    "text": "번역의 어려움 3\n\n영어 용어를 한국어로 변경하는 방식\n\n외국어 표기법\n\n예제: custom, 커스텀\n장점: 번역의 편리성, 영어 단어의 의미를 안다면 이해가 쉬움\n단점: 생소한 영어단어의 경우 의미 전달이 어려움, 번역의 장점이 없음\n\n한국어 사용\n\n예제: custom, 사용자정의\n장점: 의미 전달이 가능함.\n단점: 적절한 한국어 단어 선택이 어려움. 올바른 단어인지 결정할 주체가 없음. 원래 영어용어를 알 수 없어 원문이나 논문을 읽을 때 어려움."
  },
  {
    "objectID": "docs/book_blog/posts/2023-07-23-dl-glossary/index.html",
    "href": "docs/book_blog/posts/2023-07-23-dl-glossary/index.html",
    "title": "딥러닝 용어 사전",
    "section": "",
    "text": "딥러닝 용어사전은 딥러닝에 사용되는 영어 용어를 한글 용어로 번역하기 위해 사용됩니다. 통일성 있는 번역 문서를 만들기 위해서 다함께 등록하고 수정하는 오픈 용어 사전입니다."
  },
  {
    "objectID": "docs/book_blog/posts/2023-09-03-data-visualization/index.html",
    "href": "docs/book_blog/posts/2023-09-03-data-visualization/index.html",
    "title": "시계열 데이터 시각화",
    "section": "",
    "text": "시계열 데이터 시각화는 시계열 데이터를 시각화하는 방법을 정리합니다."
  },
  {
    "objectID": "docs/book_blog/posts/2023-08-27-korean-study/index.html",
    "href": "docs/book_blog/posts/2023-08-27-korean-study/index.html",
    "title": "Korean Study Book",
    "section": "",
    "text": "It is the book for Korean Study"
  },
  {
    "objectID": "docs/book_blog/posts/2023-08-25-hf-examples/index.html",
    "href": "docs/book_blog/posts/2023-08-25-hf-examples/index.html",
    "title": "HuggingFace Examples",
    "section": "",
    "text": "허깅페이스 예제코드를 정리하는 온라인 책입니다."
  },
  {
    "objectID": "docs/bookshelf/glossary/index.html",
    "href": "docs/bookshelf/glossary/index.html",
    "title": "BookShelf",
    "section": "",
    "text": "</div>\n\n<!-- </table> -->\n<!-- ::: -->\n<!--\n <iframe src=\"iframe.html\" id=\"iframe\" onload=\"Height();\" frameborder=\"0\" scrolling=\"no\" style=\"overflow-x:hidden; overflow:auto; width:100%; min-height:500px;\"> -->"
  },
  {
    "objectID": "docs/bookshelf/data_visualization/references.html",
    "href": "docs/bookshelf/data_visualization/references.html",
    "title": "BookShelf",
    "section": "",
    "text": "References"
  },
  {
    "objectID": "docs/bookshelf/data_visualization/time_series_basic.html",
    "href": "docs/bookshelf/data_visualization/time_series_basic.html",
    "title": "BookShelf",
    "section": "",
    "text": "시계열 데이터는 일정 시간간격을 측정된 정보한 데이터입니다. 시계열 데이터는 시간의 흐름에 따라서 테이터가 갖는 특징을 확인하기 위해서 생성되며 금융 정보나 생체 정보등의 특징을 저장하는 경우가 많습니다.\nPandas는 시계열 데이터를 관리하기 위한 많은 기능을 제공합니다. 데이터의 추세, 주기성 등을 파악할 수 있고 필요한 경우 예측 모델링을 할 수 있습니다. 그리고 원하는 형태의 시간을 표시할 수 있도록 DatetimeIndex, Timestamp, Teimdelta등 다양한 함수를 지원하고 있습니다.\n\n\n시계열 데이터를 이해하기 위해서 데이터를 구성하는 날짜를 어떻게 지정하는 지 이해해야 합니다. 파이썬은 날짜와 시간을 나타내는 datetime클래스를 제공합니다. 그리고 Pandas는 datetime객체를 Timestamp 객체로 변화시켜 사용합니다.\n\nfrom datetime import datetime\nnew_year = datetime(2023, 1, 1, 0, 0)\nnew_year\n\ndatetime.datetime(2023, 1, 1, 0, 0)\n\n\ndatetime객체를 이용하여 2023년 1월 1일 0시 0분을 나타내는 객체를 생성하였습니다. 이제 Timestamp를 이용하여 특정 시점을 표현합니다.\n\nimport pandas as pd\ntime_start = pd.Timestamp('2002-5-5 13:00')\ntime_start\n\nTimestamp('2002-05-05 13:00:00')\n\n\n이제 Pandas의 시계열 데이터의 특정시점을 지정하기 위해서 Timestamp 객체를 생성할 수 있습니다. 하지만 시간 정보를 전달 받는 대부분의 라이브러리는 내부적으로 Timestamp객체로 만들어 데이터를 처리하기 때문에 날짜 및 시간을 표시하는 문자열을 전달 받습니다.\n만약 이와 같이 구성하지 않고 생각해보면 매번 Timestamp나 datetime 클래스로 시간 정보를 변경해서 전달 해야 했다면 매우 불편했을 것 같습니다.\n시계열 데이터는 데이터의 인덱스로 시간 정보를 사용하는 경우가 대부분입니다. Pandas에서는 Timestamp 데이터로 정의된 인덱스인 DatetimeIndex객체를 사용합니다. 시계열 데이터로 데이터 프레임을 생성하고 이 데이터 프레임 index가 어떤 데이터 형인지 알아봅니다.\n\ndates = pd.Series([10, 20], [pd.Timestamp('2023-1-1'), pd.Timestamp('2023-1-2')])\nprint(type(dates.index))\ndisplay(dates)\n\n<class 'pandas.core.indexes.datetimes.DatetimeIndex'>\n\n\n2023-01-01    10\n2023-01-02    20\ndtype: int64\n\n\n위의 코드에서 dates라는 이름으로 pandas series데이터를 생성했습니다. 데이터와 함께 index로 Timestamp정보가 전달됩니다. dates series 데이터에 전달된 Timestamp는 인덱스로 사용되면서 데이터형은 DatetimeIndex로 설정되었습니다.\n\ndf = pd.DataFrame({'data': [10, 20]},\n                    index = pd.to_datetime(['2023-1-1', '2023-1-2']))\nprint(type(df.index))\ndisplay(df)\n\n<class 'pandas.core.indexes.datetimes.DatetimeIndex'>\n\n\n\n\n\n\n  \n    \n      \n      data\n    \n  \n  \n    \n      2023-01-01\n      10\n    \n    \n      2023-01-02\n      20\n    \n  \n\n\n\n\n위의 코드는 df 데이터 프레임 생성 시 index정보를 to_datetime()함수를 이용하여 Timestamp로 변환하고 이를 index로 전달했습니다. 데이터 프레임의 index는 이전 예제와 같이 DatetimeIndex로 표시됩니다.\n\n\n\n\n\n\nTip\n\n\n\n하지만 매번 Timestamp객체를 만들어 전달하는 것을 코드의 가독성을 낮추는 문제가 있습니다. to_dateteime함수는 Pandas는 Timestamp로 전달될 수 있는 문자열을 Timestamp로 변환할 수 있기 때문에 좀 더 효율적으로 DatetimeIndex를 생성할 수 있습니다.\n\n\n\n\n\n\n\nTimedelta 클래스는 시간간격을 표시하기 위해 사용됩니다. 두 날짜 사이의 차이를 계산하거나 간격을 계산하기 위해서 사용됩니다. Timedelta를 사용하기 위해서는 datatime 패키지에서 Timedelta를 import해야 합니다.\n\nimport pandas as pd\nfrom datetime import datetime, timedelta\nnow = datetime.now()\nbefore_7days = now - timedelta(days=7)\ndisplay(before_7days)\n\ndatetime.datetime(2023, 9, 4, 8, 7, 29, 80555)\n\n\n예를 들어 시계열 데이터의 현재시점에서 7일전 데이터와의 차이를 확인하기 위해서는 현재 시점에서 원하는 날짜 차이를 빼야 합니다. timedelta를 사용하여 현재 시간에서 7일전을 계산한 결과가 출력되었습니다.\n\n\n\nDateOffset은 정기적인 증가 또는 감소를 표현하기 위한 시간적 크기를 표현합니다. 일정 시점에서 자신이 원하는 시간 간격만큼 더하거나 빼는 수학적 연산을 DateOffset을 이용하여 수행합니다.\n\ndate = pd.Timestamp('2023-01-01')\noffset_3days = pd.DateOffset(days = 3)\noffset_3hours = pd.DateOffset(hours = 3)\ndisplay(date + offset_3days)\ndisplay(date + offset_3hours)\n\nTimestamp('2023-01-04 00:00:00')\n\n\nTimestamp('2023-01-01 03:00:00')\n\n\n2023년 1월 1일을 나타내는 date에 3일과 3시간 간격의 DateOffset 객체를 더해 지정한 간격의 날짜 정보를 얻을 수 있습니다.\n\n\n\n\n\n\nRange class는 일정 시간 간격으로 시계열 데이터를 만들어야하는 경우 사용됩니다. 년도, 분기, 월 등 다양한 시간간격을 나타낼 수 있으며 이를 이용하여 일정한 간격의 시계열 데이터를 처리하는 경우에 사용할 수 있습니다.\n예를 들어 특정한 시작날짜와 종료날짜 사이의 기간을 주단위로 시간간격으로 정보를 확인해야하는 경우 사용될 수 있습니다.\n\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range('2023-1-1', '2023-5-1', freq = 'W')\ndf = pd.DataFrame({'date' : dates,\n                   'value' : range(len(dates))})\ndisplay(dates)\ndisplay(df.head())\n\nDatetimeIndex(['2023-01-01', '2023-01-08', '2023-01-15', '2023-01-22',\n               '2023-01-29', '2023-02-05', '2023-02-12', '2023-02-19',\n               '2023-02-26', '2023-03-05', '2023-03-12', '2023-03-19',\n               '2023-03-26', '2023-04-02', '2023-04-09', '2023-04-16',\n               '2023-04-23', '2023-04-30'],\n              dtype='datetime64[ns]', freq='W-SUN')\n\n\n\n\n\n\n  \n    \n      \n      date\n      value\n    \n  \n  \n    \n      0\n      2023-01-01\n      0\n    \n    \n      1\n      2023-01-08\n      1\n    \n    \n      2\n      2023-01-15\n      2\n    \n    \n      3\n      2023-01-22\n      3\n    \n    \n      4\n      2023-01-29\n      4\n    \n  \n\n\n\n\ndates는 date_range()함수에 전달된 시작시점과 종료시점 사이를 freq로 전달된 간격만큼 떨어진 시간 정보를 생성했습니다. freq로 전달될 수 있는 주요 offset정보는 아래와 같습니다. 자세한 내용은 Pandas API 문서에서 확인 합니다.\n\n\n\nAlias\nDescription\n\n\n\n\nB\nbusiness day frequency\n\n\nBM\nbusiness month end frequency\n\n\nMS\nmonth start frequency\n\n\nQ\nquarter end frequency\n\n\nW-MON\nweekly frequency (Mondays)\n\n\n\nW-MON은 고정 오프셋으로 특정 날짜를 기준으로하는 빈도가 필요할 때 사용합니다. 위의 예제의 기간 중 매주 월요일을 간격으로 날짜를 생성하는 예제를 확인합니다.\n\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range('2023-1-1', '2023-5-1', freq = 'W-MON')\ndf = pd.DataFrame({'date' : dates,\n                   'value' : range(len(dates))})\ndisplay(df.head())\n\n\n\n\n\n  \n    \n      \n      date\n      value\n    \n  \n  \n    \n      0\n      2023-01-02\n      0\n    \n    \n      1\n      2023-01-09\n      1\n    \n    \n      2\n      2023-01-16\n      2\n    \n    \n      3\n      2023-01-23\n      3\n    \n    \n      4\n      2023-01-30\n      4\n    \n  \n\n\n\n\n생성된 데이터 프레임의 처음 날짜는 2023년 1월 1일이 아니고 해당 기간 중 첫 번째 월요일인 2023년 1월 2일로 날짜가 생성되었습니다.\n\n\n\n일정 시점에서 한달 간격으로 수행하는 작업이 있는 경우 Period를 사용할 수 있습니다. Period는 Timestamp와 DateOffset으로 생성한는 시간 데이터를 더 효율적으로 관리할 수 있도록 합니다.\n\nperiods = pd.Period('2023-1-1', freq='M')\ndisplay(periods)\ndisplay(periods+1)\n\nPeriod('2023-01', 'M')\n\n\nPeriod('2023-02', 'M')\n\n\n\n\n\n\n다양한 시계열 데이터를 만들면서 Pandas에서 제공하는 시계열 데이터 생성 기능을 배워봅니다.\n\n\nPandas에서 제공하는 to_datetime()'과date_range()` 함수를 이용해서 시계열 데이터를 만들어 봅니다.\n\nindex = pd.to_datetime(['2023-1-1', '2023-2-28', '2023-3-31', '2023-4-30'])\ndata = range(len(index))\ndf = pd.DataFrame({'data': data},\n                    index = index)\nprint(type(df.index))\ndisplay(df)\n\n<class 'pandas.core.indexes.datetimes.DatetimeIndex'>\n\n\n\n\n\n\n\n  \n    \n      \n      data\n    \n  \n  \n    \n      2023-01-01\n      0\n    \n    \n      2023-02-28\n      1\n    \n    \n      2023-03-31\n      2\n    \n    \n      2023-04-30\n      3\n    \n  \n\n\nFigure 1: 데이터프레임 생성, to_datetime()\n\n\n\n위의 예제에서는 to_datetime()함수로 일정 시간 정보를 데이터 프레임의 index로 전달하여 데이터 프레임을 생성합니다. 데이터 프레임의 index는 DateTimeIndex로 표시되었습니다.\n\nindex = pd.date_range('2023-1-1', '2023-5-1', freq = 'M')\ndata = range(len(index))\ndf = pd.DataFrame({'data' : data},\n                   index = index)\ndisplay(df)\n\n\n\n\n\n\n  \n    \n      \n      data\n    \n  \n  \n    \n      2023-01-31\n      0\n    \n    \n      2023-02-28\n      1\n    \n    \n      2023-03-31\n      2\n    \n    \n      2023-04-30\n      3\n    \n  \n\n\nFigure 2: 데이터프레임 생성, date_range()\n\n\n\nSection 1.3.2 에서 사용한 date_range()함수를 이용하면 Figure 1 와 같이 to_datatime()함수 이용한 시간 정보가 동일한 간격이라면 Figure 2 처럼 date_range()함수를 이용해 다시 간략하게 표현할 수 있습니다."
  },
  {
    "objectID": "docs/bookshelf/data_visualization/time_series_analysis.html",
    "href": "docs/bookshelf/data_visualization/time_series_analysis.html",
    "title": "BookShelf",
    "section": "",
    "text": "KOSPI주가 정보를 저장한 시계열 데이터를 이용해서 정보를 분석하는 연습을 합니다. 시계열데이터 분석을 위해서 시간에 따라 이동시키거나 일정 주기로 추출하는 작업을 수행을 합니다. 일정 기간동안의 통계적 특성을 분석하기 위해서 window을 만들고 이동할 수도 있습니다.\n우선 연습을 위해서 KOSPI주가 정보를 가져옵니다. KOSPI주가 정보를 가져오기 위해 FinanceDataReader 라이브러리를 사용합니다. DataReader함수에 시계열 정보를 가져올 주식 종목 기호 KS11과 시작 시점을 전달합니다.\n\nimport pandas as pd\nimport numpy as np\nimport FinanceDataReader as fdr\n\nstock_name = 'KS11'\ndf = fdr.DataReader(stock_name, start = '2022-1-1')\ndisplay(df.head(5))\n\n\n\n\n\n\n  \n    \n      \n      Open\n      High\n      Low\n      Close\n      Adj Close\n      Volume\n    \n    \n      Date\n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2022-01-04\n      2991.969971\n      2995.250000\n      2973.080078\n      2989.239990\n      2989.239990\n      621200\n    \n    \n      2022-01-05\n      2984.050049\n      2986.199951\n      2936.729980\n      2953.969971\n      2953.969971\n      786900\n    \n    \n      2022-01-06\n      2925.399902\n      2952.540039\n      2915.379883\n      2920.530029\n      2920.530029\n      785500\n    \n    \n      2022-01-07\n      2933.780029\n      2959.030029\n      2933.100098\n      2954.889893\n      2954.889893\n      545800\n    \n    \n      2022-01-10\n      2947.370117\n      2951.120117\n      2910.899902\n      2926.719971\n      2926.719971\n      477000\n    \n  \n\n\nFigure 1: KOPI 시계열 데이터\n\n\n\n리턴된 데이터를 간단하게 살펴봅니다. 시간 정보로 Index가 표시되고 주가 정보는 각 컬럼에 표시됩니다. 해당 시점의 고점, 저점, 종가, 수정 종가, 시가 총액이 각각 컬럼으로 있습니다.\nFigure 1 의 index의 데이터 형식은 DatetimeIndex로 출력됩니다. 따라서 시계열 데이터 분석에 사용할 수 있는 Pandas 기능을 사용할 수 있습니다.\n\n\n시간을 이동시키는 명령어인 shift()함수를 알아봅니다. shift()함수는 지정한 수만큼 인덱스를 이동 시키는 명령입니다. Figure 1 데이터 프레임은 한국 주식 시장이 운영기간을 하루 단위로 측정된 시계열 데이터 프레임입니다. shift()명령을 이용하여 Close컬럼 데이터를 1개 Index크기 만큼 앞으로 이동합니다.\n\ndf['Close+1'] = df['Close'].shift(1)\ndisplay(df[['Close', 'Close+1']].head(5))\n\n\n\n\n\n  \n    \n      \n      Close\n      Close+1\n    \n    \n      Date\n      \n      \n    \n  \n  \n    \n      2022-01-04\n      2989.239990\n      NaN\n    \n    \n      2022-01-05\n      2953.969971\n      2989.239990\n    \n    \n      2022-01-06\n      2920.530029\n      2953.969971\n    \n    \n      2022-01-07\n      2954.889893\n      2920.530029\n    \n    \n      2022-01-10\n      2926.719971\n      2954.889893\n    \n  \n\n\n\n\n비교를 쉽게하기 위해서 Close와 Close+1 컬럼만 표시하여 결과를 확인합니다. 새롭게 생성한 Close+1 컬럼은 Close 컬럼이 이동되어 저장되었습니다. 정보를 가져올 수 없는 2023-01-02 인덱스 정보는 NaN으로 표시됩니다.\n\n\n\n시계열 데이터 프레임을 새로운 빈도로 변환하기 위해서 as_freq()함수를 사용합니다. KOSPI주가 데이터의 월별 종가 정보를 확인할 수 있도록 이 함수를 사용해 봅니다.\n\ndf_monthly = df.asfreq('M')\ndisplay(df_monthly.head(5))\n\n\n\n\n\n  \n    \n      \n      Open\n      High\n      Low\n      Close\n      Adj Close\n      Volume\n      Close+1\n    \n    \n      Date\n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2022-01-31\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      2022-02-28\n      2663.000000\n      2699.179932\n      2658.250000\n      2699.179932\n      2699.179932\n      613300.0\n      2676.760010\n    \n    \n      2022-03-31\n      2743.239990\n      2765.199951\n      2743.199951\n      2757.649902\n      2757.649902\n      1029500.0\n      2746.739990\n    \n    \n      2022-04-30\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      2022-05-31\n      2666.879883\n      2685.899902\n      2654.320068\n      2685.899902\n      2685.899902\n      670700.0\n      2669.659912\n    \n  \n\n\n\n\n결과를 보면 NaN으로 데이터가 처리된 부분이 있습니다. 2020년 1월 31일과 2022년 4월 30일 데이터는 왜 없는 걸까요?\n\nstart_day = pd.Timestamp('2022-01-28 00:00:00')\nend_day = start_day + pd.DateOffset(days = 10)\ndf.loc[start_day : end_day, :]\n\n\n\n\n\n  \n    \n      \n      Open\n      High\n      Low\n      Close\n      Adj Close\n      Volume\n      Close+1\n    \n    \n      Date\n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2022-01-28\n      2617.870117\n      2668.590088\n      2591.530029\n      2663.340088\n      2663.340088\n      433700\n      2614.489990\n    \n    \n      2022-02-03\n      2706.340088\n      2735.340088\n      2702.780029\n      2707.820068\n      2707.820068\n      435300\n      2663.340088\n    \n    \n      2022-02-04\n      2714.830078\n      2751.800049\n      2712.870117\n      2750.260010\n      2750.260010\n      535900\n      2707.820068\n    \n    \n      2022-02-07\n      2750.699951\n      2750.699951\n      2718.939941\n      2745.060059\n      2745.060059\n      417600\n      2750.260010\n    \n  \n\n\n\n\n시작일을 2022-01-28일로 설정하고 시작일로 부터 10일 간격 뒤의 시간을 종료일로 설정 후 해당 위치의 데이터 프레임 정보를 확인합니다. 1월의 마지막은 1월 31일이지만 주식시장은 1월 28일 거래로 폐장 후 2월에 개장하기 때문에 데이터가 없는 상태입니다.\nasfreq()로 간격을 설정한 기준은 월말을 기준으로 했기 때문에 해당 시점에 데이터가 없어 NaN으로 결과가 출력 되었습니다.\n\n\n\n\n\n\nTip\n\n\n\n새로운 시간 단위를 설정 시 새롭게 설정하는 시간간격에 맞는 원데이터가 없는 경우 NaN으로 데이터가 표시되기 때문에 결과에 유의 해야합니다.\n\n\n주식정보를 갖는 이 데이터 프레임의 특성 상 해당 날짜에 주가 정보가 없다면 직전 날짜의 주가 정보를 유지하면 될 것 같습니다. 1월 28일의 마지막 주가 정보를 1월말 주가 정보로 대체해도 문제가 없는 데이터이기 때문에 as_freq()함수의 method인자를 이용합니다.\nmethod인자에는 NaN으로 표시된 결측치를 어떤 정보로 채울지 결정할 정보를 전달합니다. API문서를 확인하면 bfill과 ffill을 지원한다고 합니다. 우리의 경우 이전 시점의 데이터로 결측치를 채울 예정이니 ffill로 설정합니다.\n\ndf_monthly = df.asfreq('M', method='ffill')\ndisplay(df_monthly.head(5))\n\n\n\n\n\n  \n    \n      \n      Open\n      High\n      Low\n      Close\n      Adj Close\n      Volume\n      Close+1\n    \n    \n      Date\n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2022-01-31\n      2617.870117\n      2668.590088\n      2591.530029\n      2663.340088\n      2663.340088\n      433700\n      2614.489990\n    \n    \n      2022-02-28\n      2663.000000\n      2699.179932\n      2658.250000\n      2699.179932\n      2699.179932\n      613300\n      2676.760010\n    \n    \n      2022-03-31\n      2743.239990\n      2765.199951\n      2743.199951\n      2757.649902\n      2757.649902\n      1029500\n      2746.739990\n    \n    \n      2022-04-30\n      2669.179932\n      2696.100098\n      2664.060059\n      2695.050049\n      2695.050049\n      975000\n      2667.489990\n    \n    \n      2022-05-31\n      2666.879883\n      2685.899902\n      2654.320068\n      2685.899902\n      2685.899902\n      670700\n      2669.659912\n    \n  \n\n\n\n\n이번에는 월말인 2022년 1월 31일 데이터가 NaN이 아니고 이전 시점의 데이터로 업데이트 된 것을 알 수 있습니다.\n\n\n\nresample()함수는 주어진 빈도로 리샘플링할 때 사용합니다. 데이터를 보간하여 빈 시간대에 대한 새로운 값을 생성합니다. 시간을 기반으로 한 데이터에 적용하는 groupby함수로 생각할 수 있습니다.\nasfreq()함수는 주기를 변경하기 위해 사용되어 해당 시점에 원데이터가 없다면 NaN으로 표시됩니다.\n\ndf_monthly = df.resample('M').last()\ndf_monthly.head(5)\n\n\n\n\n\n  \n    \n      \n      Open\n      High\n      Low\n      Close\n      Adj Close\n      Volume\n      Close+1\n    \n    \n      Date\n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2022-01-31\n      2617.870117\n      2668.590088\n      2591.530029\n      2663.340088\n      2663.340088\n      433700\n      2614.489990\n    \n    \n      2022-02-28\n      2663.000000\n      2699.179932\n      2658.250000\n      2699.179932\n      2699.179932\n      613300\n      2676.760010\n    \n    \n      2022-03-31\n      2743.239990\n      2765.199951\n      2743.199951\n      2757.649902\n      2757.649902\n      1029500\n      2746.739990\n    \n    \n      2022-04-30\n      2669.179932\n      2696.100098\n      2664.060059\n      2695.050049\n      2695.050049\n      975000\n      2667.489990\n    \n    \n      2022-05-31\n      2666.879883\n      2685.899902\n      2654.320068\n      2685.899902\n      2685.899902\n      670700\n      2669.659912\n    \n  \n\n\n\n\n\n\nresample()함수에 시간 간격이 전달된 후 리턴되는 객체는 DatetimeIndexResampler입니다. 이 객체에 시간단위로 그룹된 데이터를 처리할 방식을 전달합니다. 월단위로 리샘플링된 그룹에 마지막 값을 취하기 위해서 last()를 수행하여 매월 마지막 주가정보로 저장되었습니다.\n\ndf_monthly = df.resample('M').mean()\ndf_monthly.head(5)\n\n\n\n\n\n  \n    \n      \n      Open\n      High\n      Low\n      Close\n      Adj Close\n      Volume\n      Close+1\n    \n    \n      Date\n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2022-01-31\n      2872.972116\n      2886.611598\n      2842.880525\n      2859.066830\n      2859.066830\n      5.516632e+05\n      2869.940538\n    \n    \n      2022-02-28\n      2722.530002\n      2740.107788\n      2703.206665\n      2724.015015\n      2724.015015\n      5.617500e+05\n      2722.023912\n    \n    \n      2022-03-31\n      2699.054316\n      2710.955694\n      2684.923840\n      2698.716192\n      2698.716192\n      6.851857e+05\n      2695.931908\n    \n    \n      2022-04-30\n      2700.210007\n      2711.937163\n      2688.504790\n      2703.242850\n      2703.242850\n      1.048310e+06\n      2706.223796\n    \n    \n      2022-05-31\n      2628.057971\n      2642.537500\n      2613.529016\n      2629.215002\n      2629.215002\n      7.979600e+05\n      2629.672510\n    \n  \n\n\n\n\n\n\nKOSPI주가 지수의 월별 평균값을 구해봅니다. 시간간격은 동일하게 월 단위이고 해당 시간 단위 데이터를 평균하기 위해 mean함수를 사용했습니다.\n\n\n\n시계열 정보에서는 여러가지 이동 통계를 사용합니다. 일반적으로 이동 평균, 이동 표준 편차등이 주로 사용됩니다. 이동 통계를 이용하면 시계열 데이터의 추세를 확인할 수 있으며 이상치 검출에도 사용할 수 있습니다. 이동 윈도우에 크기에 따라서 데이터를 부드럽게 만들 수 있기 때문에 데이터가 가지는 불필요한 고주파 노이즈를 제거할 수 있습니다.\nPandas에서는 rolling()함수로 롤링 윈도우를 지원합니다. 이 함수를 이용해서 KOSPI 지수의 60일 이동평균값을 확인해봅니다.\n\ndf_monthly = df.rolling('60d').mean()\ndf_monthly.head(5)\n\n\n\n\n\n  \n    \n      \n      Open\n      High\n      Low\n      Close\n      Adj Close\n      Volume\n      Close+1\n    \n    \n      Date\n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2022-01-04\n      2991.969971\n      2995.250000\n      2973.080078\n      2989.239990\n      2989.239990\n      621200.0\n      NaN\n    \n    \n      2022-01-05\n      2988.010010\n      2990.724976\n      2954.905029\n      2971.604981\n      2971.604981\n      704050.0\n      2989.239990\n    \n    \n      2022-01-06\n      2967.139974\n      2977.996663\n      2941.729980\n      2954.579997\n      2954.579997\n      731200.0\n      2971.604981\n    \n    \n      2022-01-07\n      2958.799988\n      2973.255005\n      2939.572510\n      2954.657471\n      2954.657471\n      684850.0\n      2954.579997\n    \n    \n      2022-01-10\n      2956.514014\n      2968.828027\n      2933.837988\n      2949.069971\n      2949.069971\n      643280.0\n      2954.657471"
  },
  {
    "objectID": "docs/bookshelf/data_visualization/time_series_visualization.html",
    "href": "docs/bookshelf/data_visualization/time_series_visualization.html",
    "title": "BookShelf",
    "section": "",
    "text": "시계열 데이터 시각화\n시계열 데이터를 시각화를 연습합니다. 시계열 데이터 중 좋은 예로 사용할 수 있는 데이터는 주식데이터일 것 같습니다. FinanceDataReader라이브러리를 이용하여 Kospi 주가 정보를 읽어오고 이를 이용하여 월별 수익률을 계산합니다.\n시계열 데이터의 경우 일정 기간을 기준으로 통계정보를 추출하고 이를 지표로 사용하는 경우가 많습니다. KOSPI 주가지수를 분석하는 예제로 시계열 데이터를 시각화합니다.\n\n\n\n                                                \n\n\nPandas 데이터 프레임으로 KOSPI 주가지수 정보를 로드하고 각각의 정보를 3개의 sub plot으로 구성하여 같이 비교할 수 있도록 위와 같이 구성합니다. 예제를 통해서 subplot을 생성하는 방법에 대해서 이해할 수 있었고 특정 시간 단위로 시계열 데이터를 처리하는 방법도 배울 수 있었습니다."
  },
  {
    "objectID": "docs/bookshelf/data_visualization/index.html",
    "href": "docs/bookshelf/data_visualization/index.html",
    "title": "BookShelf",
    "section": "",
    "text": "Welcome\n데이터 시각화 과정을 정리하고 결과를 정리하기 위한 책입니다.\n배움을 잘 이해하고 기억하는 가장 좋은 방법은 정리하여 글로 남기는 것이라고 생각합니다. 다만 배운 내용을 정리하는 과정에 잘못된 정보가 있을 수 있습니다.\n읽으시며 중요한 내용이 있다면 틀린 부분이 있는 지 다시 확인해 주시길 부탁드립니다. 이 책을 만들면서 데이터 시각화에 대해서 좀 더 잘 이해하고 더불어 이 책을 보는 분들에게도 도움이 되면 좋겠습니다.\n감사합니다."
  },
  {
    "objectID": "docs/bookshelf/data_visualization/intro.html",
    "href": "docs/bookshelf/data_visualization/intro.html",
    "title": "BookShelf",
    "section": "",
    "text": "Introduction\n데이터 시각화 과정을 정리하고 결과를 정리하기 위한 책입니다."
  },
  {
    "objectID": "docs/bookshelf/data_visualization/summary.html",
    "href": "docs/bookshelf/data_visualization/summary.html",
    "title": "BookShelf",
    "section": "",
    "text": "Summary\nIn summary, this book has no content whatsoever."
  },
  {
    "objectID": "docs/blog/index.html",
    "href": "docs/blog/index.html",
    "title": "Blog",
    "section": "",
    "text": "Pandas 데이터프레임 머지\n\n\nPandas 데이터프레임 머지하기\n\n\n\n\nPandas\n\n\n\n\nPandas 데이터프레임을 머지하는 방법을 정리합니다.\n\n\n\n\n\n\nSep 11, 2023\n\n\n양성모\n\n\n\n\n\n\n  \n\n\n\n\nQuarto Callout Block\n\n\nCallout Block으로 내용 강조하기\n\n\n\n\nQuarto\n\n\n\n\nQuarto Callout으로 내용 강조하는 방법을 정리합니다.\n\n\n\n\n\n\nSep 10, 2023\n\n\n양성모\n\n\n\n\n\n\n  \n\n\n\n\nPandas 데이터 전처리\n\n\nPandas 데이터 타입 변경 전처리\n\n\n\n\nPandas\n\n\n\n\nPandas 데이터 타입을 변경하는 방법, 데이터 전처리 방법을 정리합니다.\n\n\n\n\n\n\nSep 10, 2023\n\n\n양성모\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-11-pandas-merge/index.html",
    "href": "docs/blog/posts/2023/09/2023-09-11-pandas-merge/index.html",
    "title": "Pandas 데이터프레임 머지",
    "section": "",
    "text": "병합은 서로다른 데이터프레임 객체에 동일하게 존재하는 값을 통해 양쪽 데이터를 연관 지어 하나의 데이터프레임으로 모델링할 수 있는 유용한 방법입니다. 연습을 위해서 데이터를 준비합니다.\nYahoo Finance에서는 미국뿐 아니라 한국 주식에 대한 정보를 제공합니다. KOSPI주식 정보를 csv형태로 저장해서 데이터프레임 머지 연습에 사용할께요. Yahoo Finance로 이동해서 historica l data 탭을 선택합니다.\n\nHistorical Data 를 선택하면 위와 같이 KOSPI 에 대한 시계열 데이터를 얻을 수 있습니다. download를 눌러 다운로드하여 저장합니다. 혹은 [KS11.csv]에서 다운로드 하세요.\n\n\ncsv파일을 불러와서 데이터프레임 형태를 확인합니다. 시계열데이터의 경우 날짜정보를 데이터프레임의 index로 사용하면 편리합니다. data컬럼을 index로 설정합니다.\n\nimport pandas as pd\nkospi = pd.read_csv(\"./^KS11.csv\", index_col ='Date')\nkospi.head()\n\n\n\n\n\n  \n    \n      \n      Open\n      High\n      Low\n      Close\n      Adj Close\n      Volume\n    \n    \n      Date\n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2022-09-13\n      2418.590088\n      2453.949951\n      2418.590088\n      2449.540039\n      2449.540039\n      366900\n    \n    \n      2022-09-14\n      2390.469971\n      2418.419922\n      2381.500000\n      2411.419922\n      2411.419922\n      461300\n    \n    \n      2022-09-15\n      2416.010010\n      2421.629883\n      2401.830078\n      2401.830078\n      2401.830078\n      423900\n    \n    \n      2022-09-16\n      2387.560059\n      2395.100098\n      2371.110107\n      2382.780029\n      2382.780029\n      440300\n    \n    \n      2022-09-19\n      2388.729980\n      2389.850098\n      2352.760010\n      2355.659912\n      2355.659912\n      403700\n    \n  \n\n\n\n\n날짜정보가 index로 설정된 데이터프레임을 생성했습니다. 이제 연결을 위한 새로운 데이터프레임을 생성합니다. 데이트 프레임을 연결할 정보를 Ticker라는 컬럼으로 설정하고 기존 데이터프레임의 Volume컬럼을 추가합니다.\n\nkospi_volume = pd.DataFrame ({'Ticker': 'kospi', 'Volume' : kospi['Volume']})\nkospi_volume.head()\n\n\n\n\n\n  \n    \n      \n      Ticker\n      Volume\n    \n    \n      Date\n      \n      \n    \n  \n  \n    \n      2022-09-13\n      kospi\n      366900\n    \n    \n      2022-09-14\n      kospi\n      461300\n    \n    \n      2022-09-15\n      kospi\n      423900\n    \n    \n      2022-09-16\n      kospi\n      440300\n    \n    \n      2022-09-19\n      kospi\n      403700\n    \n  \n\n\n\n\n2개의 데이터프레임이 함께 갖는 컬럼인 ’Ticker’를 통해서 병합을 진행하고 이를 통해서 Volume정보를 추가하려고 합니다. 올바르게 동작하는 지 확인하기 위해서 기존 데이터프레임의 Volume 컬럼을 삭제합니다.\n\nkospi['Ticker'] = 'kospi'\nkospi.pop('Volume')\nkospi.head()\n\n\n\n\n\n  \n    \n      \n      Open\n      High\n      Low\n      Close\n      Adj Close\n      Ticker\n    \n    \n      Date\n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2022-09-13\n      2418.590088\n      2453.949951\n      2418.590088\n      2449.540039\n      2449.540039\n      kospi\n    \n    \n      2022-09-14\n      2390.469971\n      2418.419922\n      2381.500000\n      2411.419922\n      2411.419922\n      kospi\n    \n    \n      2022-09-15\n      2416.010010\n      2421.629883\n      2401.830078\n      2401.830078\n      2401.830078\n      kospi\n    \n    \n      2022-09-16\n      2387.560059\n      2395.100098\n      2371.110107\n      2382.780029\n      2382.780029\n      kospi\n    \n    \n      2022-09-19\n      2388.729980\n      2389.850098\n      2352.760010\n      2355.659912\n      2355.659912\n      kospi\n    \n  \n\n\n\n\nVolume컬럼이 삭제되었으니 병합을 진행합니다. pd.merge()함수를 사용하고 공통 컬럼인 Ticker컬럼을 전달합니다.\n\nmerged_df = pd.merge(kospi, kospi_volume, on='Ticker')\nmerged_df.head()\n\n\n\n\n\n  \n    \n      \n      Open\n      High\n      Low\n      Close\n      Adj Close\n      Ticker\n      Volume\n    \n  \n  \n    \n      0\n      2418.590088\n      2453.949951\n      2418.590088\n      2449.540039\n      2449.540039\n      kospi\n      366900\n    \n    \n      1\n      2418.590088\n      2453.949951\n      2418.590088\n      2449.540039\n      2449.540039\n      kospi\n      461300\n    \n    \n      2\n      2418.590088\n      2453.949951\n      2418.590088\n      2449.540039\n      2449.540039\n      kospi\n      423900\n    \n    \n      3\n      2418.590088\n      2453.949951\n      2418.590088\n      2449.540039\n      2449.540039\n      kospi\n      440300\n    \n    \n      4\n      2418.590088\n      2453.949951\n      2418.590088\n      2449.540039\n      2449.540039\n      kospi\n      403700\n    \n  \n\n\n\n\n이제 새로운 merged_df 데이터프레임은 2개의 데이터프레임을 연결하여 Volume정보를 추가 하였습니다."
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-10-quarto-callout/index.html",
    "href": "docs/blog/posts/2023/09/2023-09-10-quarto-callout/index.html",
    "title": "Quarto Callout Block",
    "section": "",
    "text": "Quarto를 이용해 문서를 작성하는 과정에서 강조할 내용이 있는 경우 Callout Block을 사용하는 것이 좋습니다. 자산이 작성한 글에 집중이 필요한 내용을 명확하게 나타낼 수 있습니다. 공부한 내용을 정리합니다."
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-10-quarto-callout/index.html#callout-종류",
    "href": "docs/blog/posts/2023/09/2023-09-10-quarto-callout/index.html#callout-종류",
    "title": "Quarto Callout Block",
    "section": "Callout 종류",
    "text": "Callout 종류\nCallout Block은 총 아래의 note, warning, important, tip, caution 5가지 종류를 갖습니다. 실제 어떻게 적용되는지 아래에서 살펴보세요.\n\n\n\n\n\n\nNote\n\n\n\nCallout note 타입을 사용합니다.\n\n\n\n\n\n\n\n\nWarning\n\n\n\nCallout warning 타입을 사용합니다.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nCallout important 타입을 사용합니다.\n\n\n\n\n\n\n\n\nTip\n\n\n\nCallout tip 타입을 사용합니다.\n\n\n\n\n\n\n\n\nDanger\n\n\n\nCallout caution 타입을 사용합니다.\n\n\nMarkdown으로 어떻게 구현하는 지 확인해봅시다. ::: 키워드를 사용했고 Callout Block형식은 {}로 표시합니다.\n::: {.callout-caution}\n# 제목을 추가합니다.\nCallout `caution` 타입을 사용합니다.\n:::\n\n\n\n\n\n\n제목을 추가합니다.\n\n\n\nCallout caution 타입을 사용합니다."
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-10-quarto-callout/index.html#다양한-사용자-설정",
    "href": "docs/blog/posts/2023/09/2023-09-10-quarto-callout/index.html#다양한-사용자-설정",
    "title": "Quarto Callout Block",
    "section": "다양한 사용자 설정",
    "text": "다양한 사용자 설정\n\n제목 추가하기\n아이콘은 유지하고 제목을 변경하고 싶은 경우가 있습니다. 이 경우 header 마크다운을 사용합니다.\n::: {.callout-caution}\n# 제목을 추가합니다.\nCallout `caution` 타입을 사용합니다.\n:::\n\n\n\n\n\n\n제목을 추가합니다.\n\n\n\nCallout caution 타입을 사용합니다.\n\n\n\n\n형태 변경하기\nCallout Block의 외형은 default, simple, minimam 형태를 지원합니다. 각각이 어떻게 표현되는지 알아봅니다.\n\n\n\n\n\n\nDefault 외형\n\n\n\ndefault 외형을 확인합니다.\n\n\n\n\n\n\n\n\nsimple 외형\n\n\n\nsimple 외형을 확인합니다.\n\n\n\n\n\n\n\n\nminimal 외형\n\n\n\nminimal 외형을 확인합니다.\n\n\n코드는 아래와 같이 사용합니다. appearance가 추가되었습니다.\n::: {.callout-note appearance=\"minimal\"}\n# Default 외형\ndefault 외형을 확인합니다.\n:::"
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-11-pandas-datatype-transform/index.html",
    "href": "docs/blog/posts/2023/09/2023-09-11-pandas-datatype-transform/index.html",
    "title": "Pandas 데이터 전처리",
    "section": "",
    "text": "데이터시각화 및 데이터분석을 위해 읽어온 원본 데이터의 데이터 타입이 올바른지 확인하지 않으면 분석과정에 사용하는 다양한 통계적 지표나 필터결과가 오류를 발생합니다. 데이터에 맞는 형식으로 변경되지 않은 데이터프레임을 사용할 때 발생하는 문제점을 확인하고 올바르게 데이터 형식으로 변경하는 과정을 정리합니다.\n\nimport pandas as pd\nimport datetime as dt\n\ndf = pd.DataFrame({\"year\": ['1900','1901','1910','2021', '2023'],\n                   \"n_sales\" : ['10EA', '20EA', '40EA', '100EA', '210EA'],\n                   \"status\" : ['good', 'bad', 'normal', 'bad', 'good']})\ndf\n\n\n\n\n\n  \n    \n      \n      year\n      n_sales\n      status\n    \n  \n  \n    \n      0\n      1900\n      10EA\n      good\n    \n    \n      1\n      1901\n      20EA\n      bad\n    \n    \n      2\n      1910\n      40EA\n      normal\n    \n    \n      3\n      2021\n      100EA\n      bad\n    \n    \n      4\n      2023\n      210EA\n      good\n    \n  \n\n\n\n\n데이터 프레임은 year, n_sales, status 3개의 컬럼을 갖습니다. 각 컬럼이 어떤 데이터 타입인지 확인해볼까요? 데이터프레임의 정보를 보여주는 info()함수로 데이터 타입을 확인합니다.\n\ndf.info()\n\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 5 entries, 0 to 4\nData columns (total 3 columns):\n #   Column   Non-Null Count  Dtype \n---  ------   --------------  ----- \n 0   year     5 non-null      object\n 1   n_sales  5 non-null      object\n 2   status   5 non-null      object\ndtypes: object(3)\nmemory usage: 248.0+ bytes\n\n\n예상했던 데이터 형식과 다릅니다. n_sales는 숫자를 표현하고 있기 때문에 int 타입으로 표현되어야 할 것 같은데 object타입이네요. 데이터 프레임의 통계정보를 보여주는 describe()함수를 사용하면 차이를 알 수 있습니다.\n\ndf['n_sales'].describe()\n\ncount        5\nunique       5\ntop       10EA\nfreq         1\nName: n_sales, dtype: object\n\n\n위의 코드 실행결과에서 확인할 수 있는 것처럼 n_sales컬럼의 통계 정보는 categorical 통계정보가 출력됩니다. 숫자로 표현되지 않아서 예상했던 평균, 표준편차 등의 정보는 알 수 없습니다.\n\n\n데이터에 대한 적절한 전처리가 되지 않는 경우 잘못된 통계정보를 이용할 수 있기 때문에 적절한 전처리가 필요합니다. 위에서 만든 데이터프레임의 각 컬럼에 올바른 데이터타입을 적용해야 합니다.\n\n\n\n\n\n\n  \n    \n      \n      year\n      n_sales\n      status\n    \n  \n  \n    \n      0\n      1900\n      10EA\n      good\n    \n    \n      1\n      1901\n      20EA\n      bad\n    \n    \n      2\n      1910\n      40EA\n      normal\n    \n    \n      3\n      2021\n      100EA\n      bad\n    \n    \n      4\n      2023\n      210EA\n      good\n    \n  \n\n\n\n\n일반적으로 데이터 타입 변경은 데이터에 대한 이해가 필요합니다. year의 경우 날짜를 표현하고 있고 n_sales의 EA는 단위이기 때문에 꼭 필요한 정보가 아니라면 삭제 가능합니다. 이 두 가지 데이터 컬럼은 숫자를 표현하고 있으니 int 타입으로 변경합니다. 마지막 status 컬럼은 명백히 categorical 데이터입니다.\n\ndf['year'] = pd.to_datetime(df['year'])\ndf['n_sales'] = df['n_sales'].str.strip('EA').astype('int')\ndf['status'] = df['status'].astype('category')\n\n위의 to_datatime()과 astype()함수를 이용해서 각 컬럼을 ‘datetime’, ‘int’, ‘categorical’ 타입으로 변경했습니다. 단위를 제거하기 위해서 ‘strip()’ 함수를 사용한 것을 참고하세요.\n\ndf.info()\n\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 5 entries, 0 to 4\nData columns (total 3 columns):\n #   Column   Non-Null Count  Dtype         \n---  ------   --------------  -----         \n 0   year     5 non-null      datetime64[ns]\n 1   n_sales  5 non-null      int64         \n 2   status   5 non-null      category      \ndtypes: category(1), datetime64[ns](1), int64(1)\nmemory usage: 345.0 bytes\n\n\n수정된 데이터 프레임은 올바른 데이터 타입을 갖습니다. 이제 데이터프레임의 통계정보를 확인하겠습니다.\n\ndf['n_sales'].describe()\n\ncount      5.000000\nmean      76.000000\nstd       82.643814\nmin       10.000000\n25%       20.000000\n50%       40.000000\n75%      100.000000\nmax      210.000000\nName: n_sales, dtype: float64\n\n\n이제 예상한 것과 같이 n_sales에 대한 평균, 표준편차 등의 통계정보를 확인할 수 있습니다."
  },
  {
    "objectID": "docs/slide_blog/posts/2023-08-27-quarto-introduction/index.html",
    "href": "docs/slide_blog/posts/2023-08-27-quarto-introduction/index.html",
    "title": "Quarto 맛보기",
    "section": "",
    "text": "Quarto 맛보기"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "온라인에 책을 만들고 싶다는 생각에 배운 것을 정리하는 사이트입니다. Quarto를 이용해서 만들었고 느리지만 꾸준이 업데이트하려고 노력하고 있습니다.\n궁금한 내용이나 함께 작성하고 싶은 책이 있다면 알려주세요. 감사합니다."
  }
]