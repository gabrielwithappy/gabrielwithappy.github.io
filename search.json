[
  {
    "objectID": "books.html",
    "href": "books.html",
    "title": "Books",
    "section": "",
    "text": "온라인 책들을 정리합니다."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Public Book",
    "section": "",
    "text": "온라인 책장입니다. 공부한 내용을 정리하고 차근차근 모아 책으로 만듭니다. 추가하고 싶은 책이 있다면 블로그에 하나씩 글을 모으는 것으로 시작합니다. 느리게 작지만 꾸준히 글쓰기를 연습합니다."
  },
  {
    "objectID": "docs/slideshelf/quarto-introduction/index.html#quart가-뭐죠",
    "href": "docs/slideshelf/quarto-introduction/index.html#quart가-뭐죠",
    "title": "Quarto 맛보기",
    "section": "Quart가 뭐죠?",
    "text": "Quart가 뭐죠?\n\n오픈소스 과학, 기술 출판 시스템\n주피터 노트북 또는 마크다운을 이용한 문서 작성\n웹페이지, 블로그, 프리젠테이션 작성\n예제\n\n(website) publickrbook.com\n(website) deep learning glossary\n(slides) Quarto 맛보기\nQuarto Gallary"
  },
  {
    "objectID": "docs/slideshelf/quarto-introduction/index.html#quarto-설치하기",
    "href": "docs/slideshelf/quarto-introduction/index.html#quarto-설치하기",
    "title": "Quarto 맛보기",
    "section": "Quarto 설치하기",
    "text": "Quarto 설치하기\n\nQuarto 공식홈페이지에서 프로그램 설치\n다양한 에디터를 지원하고 있음\n\nVSCODE\nJupyter Notebook\nR\nNewvim"
  },
  {
    "objectID": "docs/slideshelf/quarto-introduction/index.html#프로젝트-생성하기",
    "href": "docs/slideshelf/quarto-introduction/index.html#프로젝트-생성하기",
    "title": "Quarto 맛보기",
    "section": "프로젝트 생성하기",
    "text": "프로젝트 생성하기\n\n프로젝트 생성\n\n# quarto create project\n ? Type\n ❯ default\n   website\n   blog\n   book\n\nQuarto 프로젝트 타입설정\n\nwebsite: 다양한 문서그룹을 통합적을 관리 가능\nblog: 블로그는 게시물 모음과 게시물을 나열하는 탐색 페이지로 구성\nbook: 온라인북에 특화된 유형의 Quarto 웹사이트"
  },
  {
    "objectID": "docs/slideshelf/quarto-introduction/index.html#metadata",
    "href": "docs/slideshelf/quarto-introduction/index.html#metadata",
    "title": "Quarto 맛보기",
    "section": "Metadata",
    "text": "Metadata\n\n_quarto.yml: 모든 Quarto프로젝트에 있으며 프로젝트 수준으로 정의가 필요한 옵션 설정\n\nproject:\n  type: website\nwebsite:\n  title: \"Public KR Book\"\n  page-footer:\n    center: \"welcome\"\n  navbar:\n    left:\n      - href: index.qmd\n        text: Home\n  sidebar:\n      collapse-level: 1\n      contents:\n        - docs/bookshelf/hf-examples/index.qmd\n        - section: \"Task별 예제\"\n          contents:\n            - section: \"Video\"\n\nKeyword 의미\n\nnabvar: 웹사이트 상단 네비게이션 바\nside-bar: 왼쪽 사이드 바\npage footer: 웹사이트 footer 정보"
  },
  {
    "objectID": "docs/slideshelf/quarto-introduction/index.html#웹사이트-렌더링-미리보기",
    "href": "docs/slideshelf/quarto-introduction/index.html#웹사이트-렌더링-미리보기",
    "title": "Quarto 맛보기",
    "section": "웹사이트 렌더링 / 미리보기",
    "text": "웹사이트 렌더링 / 미리보기\n\n렌터링 대상 파일은 Quarto에서 인식가능한 모든 파일\n\n.qmd, .ipynb, .md, .Rmd\n\n렌터링시 문서를 사용해서 html 코드를 생성\n\n프로젝트 타입에 따라서 특정 폴더에 저장됨\nwebsite 타입의 경우_site 디렉토리에 저장됨\n\n렌더링 : Quarto가 인식한 문서를 html코드 형식으로 변경하는 과정\n\n# quarto render\n\n// 다양한 방식으로 렌더링 가능\n# quarto render document.qmd --to pdf\n# quarto render document.qmd --to docx\n\n웹사이트 미리보기\n\nquarto preview"
  },
  {
    "objectID": "docs/slideshelf/quarto-introduction/index.html#웹사이트-배포하기",
    "href": "docs/slideshelf/quarto-introduction/index.html#웹사이트-배포하기",
    "title": "Quarto 맛보기",
    "section": "웹사이트 배포하기",
    "text": "웹사이트 배포하기\n\nQuarto는 웹페이지로 배포하기 위해서 Quarto Pub, Github Pages등을 지원합니다.\n\n# quarto publish\n? Provider:\n  Quarto Pub\n❯ GitHub Pages\n  RStudio Connect\n  Netlify\n - 배포 사이트 정보 - Quarto Pub : Quarto에서 quarto를 이용한 웹페이지를 배포하기 위해 제공 - GitHub Pages : 깃헙에서 정적 웹페이지를 지원하기 위해서 제공"
  },
  {
    "objectID": "docs/slideshelf/quarto-introduction/index.html#번역의-어려움-1",
    "href": "docs/slideshelf/quarto-introduction/index.html#번역의-어려움-1",
    "title": "Quarto 맛보기",
    "section": "번역의 어려움 1",
    "text": "번역의 어려움 1\n\n일관성 있게 용어를 사용하기가 어려움\n\n번역하는 사람이 여러 명이기 때문에 동일한 용어를 다르게 번역하는 경우가 발생함\n한국어 문장 형식이 서로 다름.\n\n~한다로 사용? 아니면 ~합니다로 사용?\n\n\n팀 내부에서 간단한 style guide를 정하면 좋다.\n\n하지만 너무 복잡하면 찾기 어려워 결국 사용 못함!\n컨센서스와 쉽게 확인할 수 있는 정도가 좋음."
  },
  {
    "objectID": "docs/slideshelf/quarto-introduction/index.html#번역의-어려움-2",
    "href": "docs/slideshelf/quarto-introduction/index.html#번역의-어려움-2",
    "title": "Quarto 맛보기",
    "section": "번역의 어려움 2",
    "text": "번역의 어려움 2\n\n번역 리뷰는 어떻게 진행하지?\n\n얼마나 자세하게 확인해야하나?\n하다보면 계속 고칠 것이 나와서 번역이 완료가 안됨! ㅠ_ㅠ\n\n번역완료에 대한 기준 (시간, 리뷰어 수를 정하자!!)\n\n\n\n번역을 하다보니 문서 자체에 대한 이해가 부족한 것 같다.\n\n번역은 다 했는데 막상 다시보니 문서내용을 이해를 못했다.\n번역 작업의 목적?\n\n문서를 이해하고 배우기 위한 것이 목적인가?\n아니면 번역 skill을 높이는 것이 목적인가?\n\n머지가 되면 자기 문서를 발표해보자."
  },
  {
    "objectID": "docs/slideshelf/quarto-introduction/index.html#번역의-어려움-3",
    "href": "docs/slideshelf/quarto-introduction/index.html#번역의-어려움-3",
    "title": "Quarto 맛보기",
    "section": "번역의 어려움 3",
    "text": "번역의 어려움 3\n\n영어 용어를 한국어로 변경하는 방식\n\n외국어 표기법\n\n예제: custom, 커스텀\n장점: 번역의 편리성, 영어 단어의 의미를 안다면 이해가 쉬움\n단점: 생소한 영어단어의 경우 의미 전달이 어려움, 번역의 장점이 없음\n\n한국어 사용\n\n예제: custom, 사용자정의\n장점: 의미 전달이 가능함.\n단점: 적절한 한국어 단어 선택이 어려움. 올바른 단어인지 결정할 주체가 없음. 원래 영어용어를 알 수 없어 원문이나 논문을 읽을 때 어려움."
  },
  {
    "objectID": "docs/slideshelf/deeplearning-translation/index.html#번역의-어려움-1",
    "href": "docs/slideshelf/deeplearning-translation/index.html#번역의-어려움-1",
    "title": "딥러닝 문서 번역하기",
    "section": "번역의 어려움 1",
    "text": "번역의 어려움 1\n\n일관성 있게 용어를 사용하기가 어려움\n\n번역하는 사람이 여러 명이기 때문에 동일한 용어를 다르게 번역하는 경우가 발생함\n한국어 문장 형식이 서로 다름.\n\n~한다로 사용? 아니면 ~합니다로 사용?\n\n\n팀 내부에서 간단한 style guide를 정하면 좋다.\n\n하지만 너무 복잡하면 찾기 어려워 결국 사용 못함!\n컨센서스와 쉽게 확인할 수 있는 정도가 좋음."
  },
  {
    "objectID": "docs/slideshelf/deeplearning-translation/index.html#번역의-어려움-2",
    "href": "docs/slideshelf/deeplearning-translation/index.html#번역의-어려움-2",
    "title": "딥러닝 문서 번역하기",
    "section": "번역의 어려움 2",
    "text": "번역의 어려움 2\n\n번역 리뷰는 어떻게 진행하지?\n\n얼마나 자세하게 확인해야하나?\n하다보면 계속 고칠 것이 나와서 번역이 완료가 안됨! ㅠ_ㅠ\n\n번역완료에 대한 기준 (시간, 리뷰어 수를 정하자!!)\n\n\n\n번역을 하다보니 문서 자체에 대한 이해가 부족한 것 같다.\n\n번역은 다 했는데 막상 다시보니 문서내용을 이해를 못했다.\n번역 작업의 목적?\n\n문서를 이해하고 배우기 위한 것이 목적인가?\n아니면 번역 skill을 높이는 것이 목적인가?\n\n머지가 되면 자기 문서를 발표해보자."
  },
  {
    "objectID": "docs/slideshelf/deeplearning-translation/index.html#번역의-어려움-3",
    "href": "docs/slideshelf/deeplearning-translation/index.html#번역의-어려움-3",
    "title": "딥러닝 문서 번역하기",
    "section": "번역의 어려움 3",
    "text": "번역의 어려움 3\n\n영어 용어를 한국어로 변경하는 방식\n\n외국어 표기법\n\n예제: custom, 커스텀\n장점: 번역의 편리성, 영어 단어의 의미를 안다면 이해가 쉬움\n단점: 생소한 영어단어의 경우 의미 전달이 어려움, 번역의 장점이 없음\n\n한국어 사용\n\n예제: custom, 사용자정의\n장점: 의미 전달이 가능함.\n단점: 적절한 한국어 단어 선택이 어려움. 올바른 단어인지 결정할 주체가 없음. 원래 영어용어를 알 수 없어 원문이나 논문을 읽을 때 어려움."
  },
  {
    "objectID": "docs/book_blog/posts/2023-07-23-dl-glossary/index.html",
    "href": "docs/book_blog/posts/2023-07-23-dl-glossary/index.html",
    "title": "딥러닝 용어 사전",
    "section": "",
    "text": "딥러닝 용어사전은 딥러닝에 사용되는 영어 용어를 한글 용어로 번역하기 위해 사용됩니다. 통일성 있는 번역 문서를 만들기 위해서 다함께 등록하고 수정하는 오픈 용어 사전입니다."
  },
  {
    "objectID": "docs/book_blog/posts/2023-09-03-data-visualization/index.html",
    "href": "docs/book_blog/posts/2023-09-03-data-visualization/index.html",
    "title": "시계열 데이터 시각화",
    "section": "",
    "text": "시계열 데이터 시각화는 시계열 데이터를 시각화하는 방법을 정리합니다."
  },
  {
    "objectID": "docs/book_blog/posts/2023-08-27-korean-study/index.html",
    "href": "docs/book_blog/posts/2023-08-27-korean-study/index.html",
    "title": "Korean Study Book",
    "section": "",
    "text": "It is the book for Korean Study"
  },
  {
    "objectID": "docs/book_blog/posts/2023-08-25-hf-examples/index.html",
    "href": "docs/book_blog/posts/2023-08-25-hf-examples/index.html",
    "title": "HuggingFace Examples",
    "section": "",
    "text": "허깅페이스 예제코드를 정리하는 온라인 책입니다."
  },
  {
    "objectID": "docs/bookshelf/glossary/index.html",
    "href": "docs/bookshelf/glossary/index.html",
    "title": "BookShelf",
    "section": "",
    "text": "</div>\n\n<!-- </table> -->\n<!-- ::: -->\n<!--\n <iframe src=\"iframe.html\" id=\"iframe\" onload=\"Height();\" frameborder=\"0\" scrolling=\"no\" style=\"overflow-x:hidden; overflow:auto; width:100%; min-height:500px;\"> -->"
  },
  {
    "objectID": "docs/bookshelf/data_visualization/time_series_basic.html",
    "href": "docs/bookshelf/data_visualization/time_series_basic.html",
    "title": "시계열 데이터",
    "section": "",
    "text": "시계열 데이터는 일정 시간간격을 측정된 정보한 데이터입니다. 시계열 데이터는 시간의 흐름에 따라서 테이터가 갖는 특징을 확인하기 위해서 생성되며 금융 정보나 생체 정보등의 특징을 저장하는 경우가 많습니다.\nPandas는 시계열 데이터를 관리하기 위한 많은 기능을 제공합니다. 데이터의 추세, 주기성 등을 파악할 수 있고 필요한 경우 예측 모델링을 할 수 있습니다. 그리고 원하는 형태의 시간을 표시할 수 있도록 DatetimeIndex, Timestamp, Teimdelta등 다양한 함수를 지원하고 있습니다."
  },
  {
    "objectID": "docs/bookshelf/data_visualization/time_series_basic.html#시간-데이터형",
    "href": "docs/bookshelf/data_visualization/time_series_basic.html#시간-데이터형",
    "title": "시계열 데이터",
    "section": "시간 데이터형",
    "text": "시간 데이터형\n시계열 데이터를 이해하기 위해서 데이터를 구성하는 날짜를 어떻게 지정하는 지 이해해야 합니다. 파이썬은 날짜와 시간을 나타내는 datetime클래스를 제공합니다. 그리고 Pandas는 datetime객체를 Timestamp 객체로 변화시켜 사용합니다.\n\nfrom datetime import datetime\nnew_year = datetime(2023, 1, 1, 0, 0)\nnew_year\n\ndatetime.datetime(2023, 1, 1, 0, 0)\n\n\ndatetime객체를 이용하여 2023년 1월 1일 0시 0분을 나타내는 객체를 생성하였습니다. 이제 Timestamp를 이용하여 특정 시점을 표현합니다.\n\nimport pandas as pd\ntime_start = pd.Timestamp('2002-5-5 13:00')\ntime_start\n\nTimestamp('2002-05-05 13:00:00')\n\n\n이제 Pandas의 시계열 데이터의 특정시점을 지정하기 위해서 Timestamp 객체를 생성할 수 있습니다. 하지만 시간 정보를 전달 받는 대부분의 라이브러리는 내부적으로 Timestamp객체로 만들어 데이터를 처리하기 때문에 날짜 및 시간을 표시하는 문자열을 전달 받습니다.\n만약 이와 같이 구성하지 않고 생각해보면 매번 Timestamp나 datetime 클래스로 시간 정보를 변경해서 전달 해야 했다면 매우 불편했을 것 같습니다.\n시계열 데이터는 데이터의 인덱스로 시간 정보를 사용하는 경우가 대부분입니다. Pandas에서는 Timestamp 데이터로 정의된 인덱스인 DatetimeIndex객체를 사용합니다. 시계열 데이터로 데이터 프레임을 생성하고 이 데이터 프레임 index가 어떤 데이터 형인지 알아봅니다.\n\ndates = pd.Series([10, 20], [pd.Timestamp('2023-1-1'), pd.Timestamp('2023-1-2')])\nprint(type(dates.index))\ndisplay(dates)\n\n<class 'pandas.core.indexes.datetimes.DatetimeIndex'>\n\n\n2023-01-01    10\n2023-01-02    20\ndtype: int64\n\n\n위의 코드에서 dates라는 이름으로 pandas series데이터를 생성했습니다. 데이터와 함께 index로 Timestamp정보가 전달됩니다. dates series 데이터에 전달된 Timestamp는 인덱스로 사용되면서 데이터형은 DatetimeIndex로 설정되었습니다.\n\ndf = pd.DataFrame({'data': [10, 20]},\n                    index = pd.to_datetime(['2023-1-1', '2023-1-2']))\nprint(type(df.index))\ndisplay(df)\n\n<class 'pandas.core.indexes.datetimes.DatetimeIndex'>\n\n\n\n\n\n\n  \n    \n      \n      data\n    \n  \n  \n    \n      2023-01-01\n      10\n    \n    \n      2023-01-02\n      20\n    \n  \n\n\n\n\n위의 코드는 df 데이터 프레임 생성 시 index정보를 to_datetime()함수를 이용하여 Timestamp로 변환하고 이를 index로 전달했습니다. 데이터 프레임의 index는 이전 예제와 같이 DatetimeIndex로 표시됩니다.\n\n\n\n\n\n\nTip\n\n\n\n하지만 매번 Timestamp객체를 만들어 전달하는 것을 코드의 가독성을 낮추는 문제가 있습니다. to_dateteime함수는 Pandas는 Timestamp로 전달될 수 있는 문자열을 Timestamp로 변환할 수 있기 때문에 좀 더 효율적으로 DatetimeIndex를 생성할 수 있습니다."
  },
  {
    "objectID": "docs/bookshelf/data_visualization/time_series_basic.html#시간-간격-표현방법",
    "href": "docs/bookshelf/data_visualization/time_series_basic.html#시간-간격-표현방법",
    "title": "시계열 데이터",
    "section": "시간 간격 표현방법",
    "text": "시간 간격 표현방법\n\nTimedelta\nTimedelta 클래스는 시간간격을 표시하기 위해 사용됩니다. 두 날짜 사이의 차이를 계산하거나 간격을 계산하기 위해서 사용됩니다. Timedelta를 사용하기 위해서는 datatime 패키지에서 Timedelta를 import해야 합니다.\n\nimport pandas as pd\nfrom datetime import datetime, timedelta\nnow = datetime.now()\nbefore_7days = now - timedelta(days=7)\ndisplay(before_7days)\n\ndatetime.datetime(2023, 9, 26, 9, 41, 10, 23080)\n\n\n예를 들어 시계열 데이터의 현재시점에서 7일전 데이터와의 차이를 확인하기 위해서는 현재 시점에서 원하는 날짜 차이를 빼야 합니다. timedelta를 사용하여 현재 시간에서 7일전을 계산한 결과가 출력되었습니다.\n\n\nDateOffset\nDateOffset은 정기적인 증가 또는 감소를 표현하기 위한 시간적 크기를 표현합니다. 일정 시점에서 자신이 원하는 시간 간격만큼 더하거나 빼는 수학적 연산을 DateOffset을 이용하여 수행합니다.\n\ndate = pd.Timestamp('2023-01-01')\noffset_3days = pd.DateOffset(days = 3)\noffset_3hours = pd.DateOffset(hours = 3)\ndisplay(date + offset_3days)\ndisplay(date + offset_3hours)\n\nTimestamp('2023-01-04 00:00:00')\n\n\nTimestamp('2023-01-01 03:00:00')\n\n\n2023년 1월 1일을 나타내는 date에 3일과 3시간 간격의 DateOffset 객체를 더해 지정한 간격의 날짜 정보를 얻을 수 있습니다."
  },
  {
    "objectID": "docs/bookshelf/data_visualization/time_series_basic.html#시간-반복-시계열-생성방법",
    "href": "docs/bookshelf/data_visualization/time_series_basic.html#시간-반복-시계열-생성방법",
    "title": "시계열 데이터",
    "section": "시간 반복 시계열 생성방법",
    "text": "시간 반복 시계열 생성방법\n\nRange\nRange class는 일정 시간 간격으로 시계열 데이터를 만들어야하는 경우 사용됩니다. 년도, 분기, 월 등 다양한 시간간격을 나타낼 수 있으며 이를 이용하여 일정한 간격의 시계열 데이터를 처리하는 경우에 사용할 수 있습니다.\n예를 들어 특정한 시작날짜와 종료날짜 사이의 기간을 주단위로 시간간격으로 정보를 확인해야하는 경우 사용될 수 있습니다.\n\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range('2023-1-1', '2023-5-1', freq = 'W')\ndf = pd.DataFrame({'date' : dates,\n                   'value' : range(len(dates))})\ndisplay(dates)\ndisplay(df.head())\n\nDatetimeIndex(['2023-01-01', '2023-01-08', '2023-01-15', '2023-01-22',\n               '2023-01-29', '2023-02-05', '2023-02-12', '2023-02-19',\n               '2023-02-26', '2023-03-05', '2023-03-12', '2023-03-19',\n               '2023-03-26', '2023-04-02', '2023-04-09', '2023-04-16',\n               '2023-04-23', '2023-04-30'],\n              dtype='datetime64[ns]', freq='W-SUN')\n\n\n\n\n\n\n  \n    \n      \n      date\n      value\n    \n  \n  \n    \n      0\n      2023-01-01\n      0\n    \n    \n      1\n      2023-01-08\n      1\n    \n    \n      2\n      2023-01-15\n      2\n    \n    \n      3\n      2023-01-22\n      3\n    \n    \n      4\n      2023-01-29\n      4\n    \n  \n\n\n\n\ndates는 date_range()함수에 전달된 시작시점과 종료시점 사이를 freq로 전달된 간격만큼 떨어진 시간 정보를 생성했습니다. freq로 전달될 수 있는 주요 offset정보는 아래와 같습니다. 자세한 내용은 Pandas API 문서에서 확인 합니다.\n\n\n\nAlias\nDescription\n\n\n\n\nB\nbusiness day frequency\n\n\nBM\nbusiness month end frequency\n\n\nMS\nmonth start frequency\n\n\nQ\nquarter end frequency\n\n\nW-MON\nweekly frequency (Mondays)\n\n\n\nW-MON은 고정 오프셋으로 특정 날짜를 기준으로하는 빈도가 필요할 때 사용합니다. 위의 예제의 기간 중 매주 월요일을 간격으로 날짜를 생성하는 예제를 확인합니다.\n\nimport pandas as pd\nimport numpy as np\n\ndates = pd.date_range('2023-1-1', '2023-5-1', freq = 'W-MON')\ndf = pd.DataFrame({'date' : dates,\n                   'value' : range(len(dates))})\ndisplay(df.head())\n\n\n\n\n\n  \n    \n      \n      date\n      value\n    \n  \n  \n    \n      0\n      2023-01-02\n      0\n    \n    \n      1\n      2023-01-09\n      1\n    \n    \n      2\n      2023-01-16\n      2\n    \n    \n      3\n      2023-01-23\n      3\n    \n    \n      4\n      2023-01-30\n      4\n    \n  \n\n\n\n\n생성된 데이터 프레임의 처음 날짜는 2023년 1월 1일이 아니고 해당 기간 중 첫 번째 월요일인 2023년 1월 2일로 날짜가 생성되었습니다.\n\n\nPeriod\n일정 시점에서 한달 간격으로 수행하는 작업이 있는 경우 Period를 사용할 수 있습니다. Period는 Timestamp와 DateOffset으로 생성한는 시간 데이터를 더 효율적으로 관리할 수 있도록 합니다.\n\nperiods = pd.Period('2023-1-1', freq='M')\ndisplay(periods)\ndisplay(periods+1)\n\nPeriod('2023-01', 'M')\n\n\nPeriod('2023-02', 'M')"
  },
  {
    "objectID": "docs/bookshelf/data_visualization/time_series_basic.html#시계열-데이터-만들기",
    "href": "docs/bookshelf/data_visualization/time_series_basic.html#시계열-데이터-만들기",
    "title": "시계열 데이터",
    "section": "시계열 데이터 만들기",
    "text": "시계열 데이터 만들기\n다양한 시계열 데이터를 만들면서 Pandas에서 제공하는 시계열 데이터 생성 기능을 배워봅니다.\n\n특정 빈도의 시계열 생성\nPandas에서 제공하는 to_datetime()'과date_range()` 함수를 이용해서 시계열 데이터를 만들어 봅니다.\n\nindex = pd.to_datetime(['2023-1-1', '2023-2-28', '2023-3-31', '2023-4-30'])\ndata = range(len(index))\ndf = pd.DataFrame({'data': data},\n                    index = index)\nprint(type(df.index))\ndisplay(df)\n\n<class 'pandas.core.indexes.datetimes.DatetimeIndex'>\n\n\n\n\n\n\n\n  \n    \n      \n      data\n    \n  \n  \n    \n      2023-01-01\n      0\n    \n    \n      2023-02-28\n      1\n    \n    \n      2023-03-31\n      2\n    \n    \n      2023-04-30\n      3\n    \n  \n\n\nFigure 1: 데이터프레임 생성, to_datetime()\n\n\n\n위의 예제에서는 to_datetime()함수로 일정 시간 정보를 데이터 프레임의 index로 전달하여 데이터 프레임을 생성합니다. 데이터 프레임의 index는 DateTimeIndex로 표시되었습니다.\n\nindex = pd.date_range('2023-1-1', '2023-5-1', freq = 'M')\ndata = range(len(index))\ndf = pd.DataFrame({'data' : data},\n                   index = index)\ndisplay(df)\n\n\n\n\n\n\n  \n    \n      \n      data\n    \n  \n  \n    \n      2023-01-31\n      0\n    \n    \n      2023-02-28\n      1\n    \n    \n      2023-03-31\n      2\n    \n    \n      2023-04-30\n      3\n    \n  \n\n\nFigure 2: 데이터프레임 생성, date_range()\n\n\n\nSection 3.2 에서 사용한 date_range()함수를 이용하면 Figure 1 와 같이 to_datatime()함수 이용한 시간 정보가 동일한 간격이라면 Figure 2 처럼 date_range()함수를 이용해 다시 간략하게 표현할 수 있습니다."
  },
  {
    "objectID": "docs/bookshelf/data_visualization/time_series_analysis.html",
    "href": "docs/bookshelf/data_visualization/time_series_analysis.html",
    "title": "시계열 데이터 분석",
    "section": "",
    "text": "KOSPI주가 정보를 저장한 시계열 데이터를 이용해서 정보를 분석하는 연습을 합니다. 시계열데이터 분석을 위해서 시간에 따라 이동시키거나 일정 주기로 추출하는 작업을 수행을 합니다. 일정 기간동안의 통계적 특성을 분석하기 위해서 window을 만들고 이동할 수도 있습니다.\n우선 연습을 위해서 KOSPI주가 정보를 가져옵니다. KOSPI주가 정보를 가져오기 위해 FinanceDataReader 라이브러리를 사용합니다. DataReader함수에 시계열 정보를 가져올 주식 종목 기호 KS11과 시작 시점을 전달합니다.\n리턴된 데이터를 간단하게 살펴봅니다. 시간 정보로 Index가 표시되고 주가 정보는 각 컬럼에 표시됩니다. 해당 시점의 고점, 저점, 종가, 수정 종가, 시가 총액이 각각 컬럼으로 있습니다.\nFigure 1 의 index의 데이터 형식은 DatetimeIndex로 출력됩니다. 따라서 시계열 데이터 분석에 사용할 수 있는 Pandas 기능을 사용할 수 있습니다."
  },
  {
    "objectID": "docs/bookshelf/data_visualization/time_series_analysis.html#shift",
    "href": "docs/bookshelf/data_visualization/time_series_analysis.html#shift",
    "title": "시계열 데이터 분석",
    "section": "shift()",
    "text": "shift()\n시간을 이동시키는 명령어인 shift()함수를 알아봅니다. shift()함수는 지정한 수만큼 인덱스를 이동 시키는 명령입니다. Figure 1 데이터 프레임은 한국 주식 시장이 운영기간을 하루 단위로 측정된 시계열 데이터 프레임입니다. shift()명령을 이용하여 Close컬럼 데이터를 1개 Index크기 만큼 앞으로 이동합니다.\n\ndf['Close+1'] = df['Close'].shift(1)\ndisplay(df[['Close', 'Close+1']].head(5))\n\n\n\n\n\n  \n    \n      \n      Close\n      Close+1\n    \n    \n      Date\n      \n      \n    \n  \n  \n    \n      2022-01-04\n      2989.239990\n      NaN\n    \n    \n      2022-01-05\n      2953.969971\n      2989.239990\n    \n    \n      2022-01-06\n      2920.530029\n      2953.969971\n    \n    \n      2022-01-07\n      2954.889893\n      2920.530029\n    \n    \n      2022-01-10\n      2926.719971\n      2954.889893\n    \n  \n\n\n\n\n비교를 쉽게하기 위해서 Close와 Close+1 컬럼만 표시하여 결과를 확인합니다. 새롭게 생성한 Close+1 컬럼은 Close 컬럼이 이동되어 저장되었습니다. 정보를 가져올 수 없는 2023-01-02 인덱스 정보는 NaN으로 표시됩니다."
  },
  {
    "objectID": "docs/bookshelf/data_visualization/time_series_analysis.html#asfreq",
    "href": "docs/bookshelf/data_visualization/time_series_analysis.html#asfreq",
    "title": "시계열 데이터 분석",
    "section": "asfreq()",
    "text": "asfreq()\n시계열 데이터 프레임을 새로운 빈도로 변환하기 위해서 as_freq()함수를 사용합니다. KOSPI주가 데이터의 월별 종가 정보를 확인할 수 있도록 이 함수를 사용해 봅니다.\n\ndf_monthly = df.asfreq('M')\ndisplay(df_monthly.head(5))\n\n\n\n\n\n  \n    \n      \n      Open\n      High\n      Low\n      Close\n      Adj Close\n      Volume\n      Close+1\n    \n    \n      Date\n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2022-01-31\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      2022-02-28\n      2663.000000\n      2699.179932\n      2658.250000\n      2699.179932\n      2699.179932\n      613300.0\n      2676.760010\n    \n    \n      2022-03-31\n      2743.239990\n      2765.199951\n      2743.199951\n      2757.649902\n      2757.649902\n      1029500.0\n      2746.739990\n    \n    \n      2022-04-30\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      2022-05-31\n      2666.879883\n      2685.899902\n      2654.320068\n      2685.899902\n      2685.899902\n      670700.0\n      2669.659912\n    \n  \n\n\n\n\n결과를 보면 NaN으로 데이터가 처리된 부분이 있습니다. 2020년 1월 31일과 2022년 4월 30일 데이터는 왜 없는 걸까요?\n\nstart_day = pd.Timestamp('2022-01-28 00:00:00')\nend_day = start_day + pd.DateOffset(days = 10)\ndf.loc[start_day : end_day, :]\n\n\n\n\n\n  \n    \n      \n      Open\n      High\n      Low\n      Close\n      Adj Close\n      Volume\n      Close+1\n    \n    \n      Date\n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2022-01-28\n      2617.870117\n      2668.590088\n      2591.530029\n      2663.340088\n      2663.340088\n      433700\n      2614.489990\n    \n    \n      2022-02-03\n      2706.340088\n      2735.340088\n      2702.780029\n      2707.820068\n      2707.820068\n      435300\n      2663.340088\n    \n    \n      2022-02-04\n      2714.830078\n      2751.800049\n      2712.870117\n      2750.260010\n      2750.260010\n      535900\n      2707.820068\n    \n    \n      2022-02-07\n      2750.699951\n      2750.699951\n      2718.939941\n      2745.060059\n      2745.060059\n      417600\n      2750.260010\n    \n  \n\n\n\n\n시작일을 2022-01-28일로 설정하고 시작일로 부터 10일 간격 뒤의 시간을 종료일로 설정 후 해당 위치의 데이터 프레임 정보를 확인합니다. 1월의 마지막은 1월 31일이지만 주식시장은 1월 28일 거래로 폐장 후 2월에 개장하기 때문에 데이터가 없는 상태입니다.\nasfreq()로 간격을 설정한 기준은 월말을 기준으로 했기 때문에 해당 시점에 데이터가 없어 NaN으로 결과가 출력 되었습니다.\n\n\n\n\n\n\nTip\n\n\n\n새로운 시간 단위를 설정 시 새롭게 설정하는 시간간격에 맞는 원데이터가 없는 경우 NaN으로 데이터가 표시되기 때문에 결과에 유의 해야합니다.\n\n\n주식정보를 갖는 이 데이터 프레임의 특성 상 해당 날짜에 주가 정보가 없다면 직전 날짜의 주가 정보를 유지하면 될 것 같습니다. 1월 28일의 마지막 주가 정보를 1월말 주가 정보로 대체해도 문제가 없는 데이터이기 때문에 as_freq()함수의 method인자를 이용합니다.\nmethod인자에는 NaN으로 표시된 결측치를 어떤 정보로 채울지 결정할 정보를 전달합니다. API문서를 확인하면 bfill과 ffill을 지원한다고 합니다. 우리의 경우 이전 시점의 데이터로 결측치를 채울 예정이니 ffill로 설정합니다.\n\ndf_monthly = df.asfreq('M', method='ffill')\ndisplay(df_monthly.head(5))\n\n\n\n\n\n  \n    \n      \n      Open\n      High\n      Low\n      Close\n      Adj Close\n      Volume\n      Close+1\n    \n    \n      Date\n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2022-01-31\n      2617.870117\n      2668.590088\n      2591.530029\n      2663.340088\n      2663.340088\n      433700\n      2614.489990\n    \n    \n      2022-02-28\n      2663.000000\n      2699.179932\n      2658.250000\n      2699.179932\n      2699.179932\n      613300\n      2676.760010\n    \n    \n      2022-03-31\n      2743.239990\n      2765.199951\n      2743.199951\n      2757.649902\n      2757.649902\n      1029500\n      2746.739990\n    \n    \n      2022-04-30\n      2669.179932\n      2696.100098\n      2664.060059\n      2695.050049\n      2695.050049\n      975000\n      2667.489990\n    \n    \n      2022-05-31\n      2666.879883\n      2685.899902\n      2654.320068\n      2685.899902\n      2685.899902\n      670700\n      2669.659912\n    \n  \n\n\n\n\n이번에는 월말인 2022년 1월 31일 데이터가 NaN이 아니고 이전 시점의 데이터로 업데이트 된 것을 알 수 있습니다."
  },
  {
    "objectID": "docs/bookshelf/data_visualization/time_series_analysis.html#resample",
    "href": "docs/bookshelf/data_visualization/time_series_analysis.html#resample",
    "title": "시계열 데이터 분석",
    "section": "resample()",
    "text": "resample()\nresample()함수는 주어진 빈도로 리샘플링할 때 사용합니다. 데이터를 보간하여 빈 시간대에 대한 새로운 값을 생성합니다. 시간을 기반으로 한 데이터에 적용하는 groupby함수로 생각할 수 있습니다.\nasfreq()함수는 주기를 변경하기 위해 사용되어 해당 시점에 원데이터가 없다면 NaN으로 표시됩니다.\n\ndf_monthly = df.resample('M').last()\ndf_monthly.head(5)\n\n\n\n\n\n  \n    \n      \n      Open\n      High\n      Low\n      Close\n      Adj Close\n      Volume\n      Close+1\n    \n    \n      Date\n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2022-01-31\n      2617.870117\n      2668.590088\n      2591.530029\n      2663.340088\n      2663.340088\n      433700\n      2614.489990\n    \n    \n      2022-02-28\n      2663.000000\n      2699.179932\n      2658.250000\n      2699.179932\n      2699.179932\n      613300\n      2676.760010\n    \n    \n      2022-03-31\n      2743.239990\n      2765.199951\n      2743.199951\n      2757.649902\n      2757.649902\n      1029500\n      2746.739990\n    \n    \n      2022-04-30\n      2669.179932\n      2696.100098\n      2664.060059\n      2695.050049\n      2695.050049\n      975000\n      2667.489990\n    \n    \n      2022-05-31\n      2666.879883\n      2685.899902\n      2654.320068\n      2685.899902\n      2685.899902\n      670700\n      2669.659912\n    \n  \n\n\n\n\n\n\nresample()함수에 시간 간격이 전달된 후 리턴되는 객체는 DatetimeIndexResampler입니다. 이 객체에 시간단위로 그룹된 데이터를 처리할 방식을 전달합니다. 월단위로 리샘플링된 그룹에 마지막 값을 취하기 위해서 last()를 수행하여 매월 마지막 주가정보로 저장되었습니다.\n\ndf_monthly = df.resample('M').mean()\ndf_monthly.head(5)\n\n\n\n\n\n  \n    \n      \n      Open\n      High\n      Low\n      Close\n      Adj Close\n      Volume\n      Close+1\n    \n    \n      Date\n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2022-01-31\n      2872.972116\n      2886.611598\n      2842.880525\n      2859.066830\n      2859.066830\n      5.516632e+05\n      2869.940538\n    \n    \n      2022-02-28\n      2722.530002\n      2740.107788\n      2703.206665\n      2724.015015\n      2724.015015\n      5.617500e+05\n      2722.023912\n    \n    \n      2022-03-31\n      2699.054316\n      2710.955694\n      2684.923840\n      2698.716192\n      2698.716192\n      6.851857e+05\n      2695.931908\n    \n    \n      2022-04-30\n      2700.210007\n      2711.937163\n      2688.504790\n      2703.242850\n      2703.242850\n      1.048310e+06\n      2706.223796\n    \n    \n      2022-05-31\n      2628.057971\n      2642.537500\n      2613.529016\n      2629.215002\n      2629.215002\n      7.979600e+05\n      2629.672510\n    \n  \n\n\n\n\n\n\nKOSPI주가 지수의 월별 평균값을 구해봅니다. 시간간격은 동일하게 월 단위이고 해당 시간 단위 데이터를 평균하기 위해 mean함수를 사용했습니다."
  },
  {
    "objectID": "docs/bookshelf/data_visualization/time_series_analysis.html#rolling",
    "href": "docs/bookshelf/data_visualization/time_series_analysis.html#rolling",
    "title": "시계열 데이터 분석",
    "section": "rolling()",
    "text": "rolling()\n시계열 정보에서는 여러가지 이동 통계를 사용합니다. 일반적으로 이동 평균, 이동 표준 편차등이 주로 사용됩니다. 이동 통계를 이용하면 시계열 데이터의 추세를 확인할 수 있으며 이상치 검출에도 사용할 수 있습니다. 이동 윈도우에 크기에 따라서 데이터를 부드럽게 만들 수 있기 때문에 데이터가 가지는 불필요한 고주파 노이즈를 제거할 수 있습니다.\nPandas에서는 rolling()함수로 롤링 윈도우를 지원합니다. 이 함수를 이용해서 KOSPI 지수의 60일 이동평균값을 확인해봅니다.\n\ndf_monthly = df.rolling('60d').mean()\ndf_monthly.head(5)\n\n\n\n\n\n  \n    \n      \n      Open\n      High\n      Low\n      Close\n      Adj Close\n      Volume\n      Close+1\n    \n    \n      Date\n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2022-01-04\n      2991.969971\n      2995.250000\n      2973.080078\n      2989.239990\n      2989.239990\n      621200.0\n      NaN\n    \n    \n      2022-01-05\n      2988.010010\n      2990.724976\n      2954.905029\n      2971.604981\n      2971.604981\n      704050.0\n      2989.239990\n    \n    \n      2022-01-06\n      2967.139974\n      2977.996663\n      2941.729980\n      2954.579997\n      2954.579997\n      731200.0\n      2971.604981\n    \n    \n      2022-01-07\n      2958.799988\n      2973.255005\n      2939.572510\n      2954.657471\n      2954.657471\n      684850.0\n      2954.579997\n    \n    \n      2022-01-10\n      2956.514014\n      2968.828027\n      2933.837988\n      2949.069971\n      2949.069971\n      643280.0\n      2954.657471"
  },
  {
    "objectID": "docs/bookshelf/data_visualization/time_series_visualization.html",
    "href": "docs/bookshelf/data_visualization/time_series_visualization.html",
    "title": "시계열 데이터 시각화",
    "section": "",
    "text": "시계열 데이터를 시각화를 연습합니다. 시계열 데이터 중 좋은 예로 사용할 수 있는 데이터는 주식데이터일 것 같습니다. FinanceDataReader라이브러리를 이용하여 Kospi 주가 정보를 읽어오고 이를 이용하여 월별 수익률을 계산합니다.\n시계열 데이터의 경우 일정 기간을 기준으로 통계정보를 추출하고 이를 지표로 사용하는 경우가 많습니다. KOSPI 주가지수를 분석하는 예제로 시계열 데이터를 시각화합니다.\n\n\n\n                                                \n\n\nPandas 데이터 프레임으로 KOSPI 주가지수 정보를 로드하고 각각의 정보를 3개의 sub plot으로 구성하여 같이 비교할 수 있도록 위와 같이 구성합니다. 예제를 통해서 subplot을 생성하는 방법에 대해서 이해할 수 있었고 특정 시간 단위로 시계열 데이터를 처리하는 방법도 배울 수 있었습니다."
  },
  {
    "objectID": "docs/bookshelf/data_visualization/index.html",
    "href": "docs/bookshelf/data_visualization/index.html",
    "title": "Welcome",
    "section": "",
    "text": "데이터 시각화 과정을 정리하고 결과를 정리하기 위한 책입니다.\n배움을 잘 이해하고 기억하는 가장 좋은 방법은 정리하여 글로 남기는 것이라고 생각합니다. 다만 배운 내용을 정리하는 과정에 잘못된 정보가 있을 수 있습니다.\n읽으시며 중요한 내용이 있다면 틀린 부분이 있는 지 다시 확인해 주시길 부탁드립니다. 이 책을 만들면서 데이터 시각화에 대해서 좀 더 잘 이해하고 더불어 이 책을 보는 분들에게도 도움이 되면 좋겠습니다.\n감사합니다."
  },
  {
    "objectID": "docs/bookshelf/data_visualization/intro.html",
    "href": "docs/bookshelf/data_visualization/intro.html",
    "title": "Introduction",
    "section": "",
    "text": "데이터 시각화 과정을 정리하고 결과를 정리하기 위한 책입니다."
  },
  {
    "objectID": "docs/bookshelf/data_visualization/summary.html",
    "href": "docs/bookshelf/data_visualization/summary.html",
    "title": "Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever."
  },
  {
    "objectID": "docs/blog/index.html",
    "href": "docs/blog/index.html",
    "title": "Blog",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n  \n\n\n\n\nGithub Pull Request 템플릿 적용하기\n\n\nGithub Pull Request 템플릿 적용하기\n\n\n\n\nDevOps\n\n\n\n\nGithub Pull Request 템플릿을 적용하는 방법을 정리합니다.\n\n\n\n\n\n\nOct 9, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\nPlotly line, shape 그리기\n\n\nPlotly line, shape 그리기\n\n\n\n\nData Visualization\n\n\n\n\nPlotly line, shape를 그리는 방법에 대해서 정리합니다.\n\n\n\n\n\n\nOct 8, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\nPlotly Funnel(깔대기) 차트 만들기\n\n\nPlotly Funnel(깔대기) 차트 만들기\n\n\n\n\nData Visualization\n\n\n\n\nPlotly Funnel(깔대기) 차트를 만드는 방법에 대해서 정리합니다.\n\n\n\n\n\n\nOct 5, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\nPlotly Zoom Disable하기\n\n\nPlotly Zoom Disable하기\n\n\n\n\nData Visualization\n\n\n\n\nPlotly Zoom을 disable하는 방법에 대해서 정리합니다.\n\n\n\n\n\n\nOct 4, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\nPlotly 차트의 축 tick 회전 및 폰트 변경하기\n\n\nPlotly x축 tick 회전 및 폰트 변경하기\n\n\n\n\nData Visualization\n\n\n\n\nPlotly의 x축 tick을 변경하는 방법에 대해서 정리합니다.\n\n\n\n\n\n\nOct 4, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\nPlotly 불릿차트\n\n\nPlotly 불릿차트\n\n\n\n\nData Visualization\n\n\n\n\nPlotly 불릿차트에 대해서 정리합니다.\n\n\n\n\n\n\nOct 3, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\nPlotly Hover 설정하기\n\n\nPlotly Hover 설정하기\n\n\n\n\nData Visualization\n\n\n\n\nPlotly Hover 레이블을 설정하는 방법을 정리합니다.\n\n\n\n\n\n\nOct 2, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\nPlotly Axis 포멧 변경하기\n\n\nPlotly Axis 포멧 변경하기\n\n\n\n\nData Visualization\n\n\n\n\nPlotly Axis 포멧 변경하기\n\n\n\n\n\n\nSep 30, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\nPlotly 마커 모양 변경하기\n\n\nPlotly 마커 모양 변경하기\n\n\n\n\nData Visualization\n\n\n\n\nPlotly 마커 모양을 변경하는 방법을 정리합니다.\n\n\n\n\n\n\nSep 28, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\nPlotly Time Series 날짜 범위 UI 사용하기\n\n\nPlotly Time Series 날짜 범위 UI 사용하기\n\n\n\n\nData Visualization\n\n\n\n\nPlotly Time Series 날짜 범위를 지정하는 방법을 정리합니다.\n\n\n\n\n\n\nSep 25, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\nPlotly Dash로 Table 표시하기\n\n\nPlotly Dash로 Table 표시하기\n\n\n\n\nData Visualization\n\n\n\n\nPlotly Dash로 Table 표시하는 방법을 정리합니다.\n\n\n\n\n\n\nSep 24, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\nPlotly Rador 차트 만들기\n\n\nPlotly Rador 차트 만들기\n\n\n\n\nData Visualization\n\n\n\n\nPlotly Rador 차트를 만드는 방법을 정리합니다.\n\n\n\n\n\n\nSep 23, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\nPlotly 3D Plot만들기\n\n\nPlotly 3D Plot만들기\n\n\n\n\nData Visualization\n\n\n\n\nPlotly 3D Plot의 사용방법을 정리합니다.\n\n\n\n\n\n\nSep 22, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\nPlotly Line Plot만들기\n\n\nPlotly Line Plot만들기\n\n\n\n\nData Visualization\n\n\n\n\nPlotly Line Plot의 사용방법을 정리합니다.\n\n\n\n\n\n\nSep 22, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\nPlotly Histogram Plot만들기\n\n\nPlotly Histogram Plot만들기\n\n\n\n\nData Visualization\n\n\n\n\nPlotly Histogram Plot의 사용방법을 정리합니다.\n\n\n\n\n\n\nSep 21, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\nPlotly Scatter Plot만들기\n\n\nPlotly Scatter Plot만들기\n\n\n\n\nData Visualization\n\n\n\n\nPlotly Scatter Plot의 사용방법을 정리합니다.\n\n\n\n\n\n\nSep 19, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\nPlotly Animation 만들기\n\n\nPlotly Animation 만들기\n\n\n\n\nData Visualization\n\n\n\n\nPlotly Animation의 사용방법을 정리합니다.\n\n\n\n\n\n\nSep 18, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\nPlotly Box Plot만들기\n\n\nPlotly Box Plot만들기\n\n\n\n\nData Visualization\n\n\n\n\nPlotly Bar Plot의 사용방법을 정리합니다.\n\n\n\n\n\n\nSep 18, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\nPlotly Treemap 만들기\n\n\nPlotly Treemap 만들기\n\n\n\n\nData Visualization\n\n\n\n\nPlotly Treemap의 사용방법과 생상변경 방법을 정리합니다.\n\n\n\n\n\n\nSep 17, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\nPlotly Bubble chart 만들기\n\n\nPlotly Bubble chart 만들기\n\n\n\n\nData Visualization\n\n\n\n\nPlotly Bubble chart의 사용방법을 정리합니다.\n\n\n\n\n\n\nSep 17, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\n날짜 범위 index 만들기\n\n\n날짜 범위 index 만들기\n\n\n\n\nPandas\n\n\n\n\n날짜 범위 index 만들기\n\n\n\n\n\n\nSep 16, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\nPandas 모든 컬럼이 NaN일 때만 삭제하기\n\n\nPandas 모든 컬럼이 NaN일 때만 삭제하기\n\n\n\n\nPandas\n\n\n\n\nPandas 모든 컬럼이 NaN일 때만 삭제하기\n\n\n\n\n\n\nSep 14, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\nPandas 중복 데이터 제거하기\n\n\nPandas 중복 데이터 제거하기\n\n\n\n\nPandas\n\n\n\n\nPandas 중복 데이터 제거하기\n\n\n\n\n\n\nSep 14, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\nPlotly Subpolt 만들기\n\n\nPlotly Subpolt 만들기\n\n\n\n\nData Visualization\n\n\n\n\nPlotly Subplt 만들기\n\n\n\n\n\n\nSep 13, 2023\n\n\n양성모\n\n\n\n\n\n\n  \n\n\n\n\nMarkdown문법 정리하기\n\n\nMarkdown문법 정리하기\n\n\n\n\nQuarto\n\n\n\n\nMarkdown문법을 정리합니다.\n\n\n\n\n\n\nSep 12, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\nPandas 데이터프레임 머지\n\n\nPandas 데이터프레임 머지하기\n\n\n\n\nPandas\n\n\n\n\nPandas 데이터프레임을 머지하는 방법을 정리합니다.\n\n\n\n\n\n\nSep 11, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\nQuarto Callout Block\n\n\nCallout Block으로 내용 강조하기\n\n\n\n\nQuarto\n\n\n\n\nQuarto Callout으로 내용 강조하는 방법을 정리합니다.\n\n\n\n\n\n\nSep 10, 2023\n\n\ngabriel yang\n\n\n\n\n\n\n  \n\n\n\n\nPandas 데이터 전처리\n\n\nPandas 데이터 타입 변경 전처리\n\n\n\n\nPandas\n\n\n\n\nPandas 데이터 타입을 변경하는 방법, 데이터 전처리 방법을 정리합니다.\n\n\n\n\n\n\nSep 10, 2023\n\n\ngabriel yang\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "docs/blog/posts/2023/10/2023-10-03-bullet-chart/index.html",
    "href": "docs/blog/posts/2023/10/2023-10-03-bullet-chart/index.html",
    "title": "Plotly 불릿차트",
    "section": "",
    "text": "불릿(bullet)차트는 데이터 시각화에서 주로 성과를 추적하고 비교하는 데 주로 사용되는 차트입니다. Plotly로 불릿차트를 그리는 방법을 정리합니다.\n블릿 차트는 대시보드나 리포트에서 성과 지표를 시각적으로 표시하는 데 자주 사용됩니다. 이러한 차트는 정보를 빠르게 파악할 수 있도록 도와줍니다.\n\n\nIndictor는 number, delta, gauge의 세 가지 시각적 요소를 갖습니다. 이들의 조합을 mode로 전달합니다. 하나씩 설정하며 차이점을 확인합니다.\n\nimport plotly.graph_objects as go\n\nfig = go.Figure()\nfig.add_trace(go.Indicator(\n    mode = \"gauge\",\n    gauge = {'axis': {'range':[None, 500]}},\n    value = 450,\n    title = {'text': \"Speed\"},\n    domain = {'row':0, 'column':0}\n))\n\nfig.add_trace(go.Indicator(\n    mode = \"gauge+number\",\n    gauge = {'axis': {'range':[None, 500]}},\n    value = 450,\n    title = {'text': \"Speed\"},\n    domain = {'row':0, 'column':1}))\n\n\nfig.add_trace(go.Indicator(\n    mode = \"gauge+delta\",\n    gauge = {'axis': {'range':[None, 500]}},\n    value = 450,\n    delta = {'reference': 500},\n    title = {'text': \"Speed\"},\n    domain = {'row':1, 'column':0}\n))\n\nfig.add_trace(go.Indicator(\n    mode = \"gauge+delta+number\",\n    gauge = {'axis': {'range':[None, 500]}},\n    value = 450,\n    delta = {'reference': 500},\n    title = {'text': \"Speed\"},\n    domain = {'row':1, 'column':1}))\n\nfig.update_layout(\n    grid = {'rows': 2, 'columns': 2, 'pattern': \"independent\"})\n\n\n                                                \n\n\n기본적인 조합을 알아보기 위해서 차트의 첫번째 컬럼을 확인합니다. 첫번째 줄은 gauge와 number를 사용한 결과를 나타냅니다. 첫번째 줄의 우측에 숫자가 추가된 것을 확인할 수 있습니다.\n최대값을 500으로 정하기 위해서 gauge = {'axis': {'range': [None, 500]}}을 사용했습니다. 범위를 지정하지 않는 경우 현재 값에 맞춰 최댓값을 자동으로 설정합니다.\n두번째 줄은 delta를 mode에 추가하고 delta의 값을 설정하기 위해서 {'reference': 500}을 사용했습니다. 500과의 차이를 화살표와 함께 표시하는 것을 알 수 있습니다.\n\n\n\n불릿차트는 angular와 bullet의 모양을 갖습니다. 동일한 설정에서 shape만 변경하여 표현하면 모양의 차이를 알 수 있습니다.\n\nimport plotly.graph_objects as go\n\nfig = go.Figure()\n\nfig.add_trace(go.Indicator(\n    mode = \"gauge+delta+number\",\n    gauge = {'axis': {'range':[None, 500]},\n             'shape': 'angular'},\n    delta = {'reference': 500},\n    value = 450,\n    title = {'text': \"Speed\"},\n    domain = {'row':0, 'column':0}\n))\n\nfig.add_trace(go.Indicator(\n    mode = \"gauge+delta+number\",\n    gauge = {'axis': {'range':[None, 500]},\n             'shape': 'bullet'},\n    delta = {'reference': 500, 'position' : \"top\"},\n    value = 450,\n    title = {'text': \"Speed\"},\n    domain = {'row':1, 'column':0}\n))\n\nfig.update_layout(\n    grid = {'rows': 2, 'columns': 1, 'pattern': \"independent\"})\n\n\n                                                \n\n\n위의 예제와 차이점은 delta에 position정보를 추가하여 두 번째 불릿차트에서는 delta정보가 위에 위치했습니다. position정보를 사용하면 delta의 표시 위치를 설정할 수 있습니다."
  },
  {
    "objectID": "docs/blog/posts/2023/10/2023-10-05-funnel-chart/index.html",
    "href": "docs/blog/posts/2023/10/2023-10-05-funnel-chart/index.html",
    "title": "Plotly Funnel(깔대기) 차트 만들기",
    "section": "",
    "text": "Funnel Chart(깔대기 차트)는 데이터의 흐름이나 과정을 시각화하기 위한 그래프 유형 중 하나입니다. 여러 세그먼트 또는 카테고리 간의 비교를 강조하는 데 사용됩니다. 각 단계 또는 세그먼트의 크기를 표시하여 이들 간의 상대적인 크기를 시각화로 표현할 수 있습니다.\n특히 비즈니스 프로세스, 온라인 판매 흐름, 고객 경로 등과 같은 순차적인 단계로 이루어진 프로세스를 분석하는 데 유용합니다. 각 단계에서 어떤 퍼센트의 항목이 소멸하거나 성공적으로 이동하는지를 보여줍니다.\n웹사이트에 방문한 고객의 흐름을 보여주는 Funnel Chart로 동작을 확인합니다.\n\nimport plotly.express as px\ndata = dict(\n    number=[39, 27.4, 20.6, 11, 2],\n    stage=[\"Website visit\", \"Downloads\", \"Potential customers\", \"Requested price\", \"invoice sent\"])\nfig = px.funnel(data, x='number', y='stage')\nfig.show()\n\n\n                                                \n\n\nFunnel 차트는 전달하는 데이터 프레임에 각 흐름의 단계에 대한 값 정보와 단계의 이름을 저장합니다. 총 5단계가 전달되었고 단계의 너비는 값에 따라 결정됩니다.\n\n\n비교를 웨해서 여러 개의 데이터를 Funnel Chart로 표시하는 방법을 정리합니다. 비교를 위해 생성한 각 데이터는 단계가 서로 다르게 설정되었습니다. 차트에 어떻게 표시되는 지 확인해보세요.\n\nfrom plotly import graph_objects as go\n\nfig = go.Figure()\n\nfig.add_trace(go.Funnel(\n    name = 'Montreal',\n    y = [\"Website visit\", \"Downloads\", \"Potential customers\", \"Requested price\"],\n    x = [100, 90, 81, 72.9],\n    textinfo = \"value+percent initial\"))\n\nfig.add_trace(go.Funnel(\n    name = 'Toronto',\n    orientation = \"h\",\n    y = [\"Website visit\", \"Downloads\", \"Potential customers\", \"Requested price\", \"invoice sent\"],\n    x = [100, 90, 81, 72.9, 65.61],\n    textposition = \"inside\",\n    textinfo = \"value+percent previous\"))\n\nfig.add_trace(go.Funnel(\n    name = 'Vancouver',\n    orientation = \"h\",\n    y = [\"Website visit\", \"Downloads\", \"Potential customers\", \"Requested price\", \"invoice sent\", \"Finalized\"],\n    x = [100, 90, 81, 72.9, 65.61, 59],\n    textposition = \"inside\",\n    textinfo = \"value+percent total\"))\n\nfig.show()\n\n\n                                                \n\n\nFunnel Chart내부에 표시되는 비율은 textinfo로 전달되는 정보로 설정됩니다. value+percent initial, value+percent previous, value+percent total의 차이를 알아봅니다. 모든 데이터는 초기값 100에서 90%만 다음 단계로 넘어가도록 구성되어 있습니다.\n\nvalue+percent initial : 현재 단계의 값을 초기값에 대한 비율로 표시합니다.\nvalue+percent previous : 현재 단계의 값을 이전 단계에 대한 비율로 표시합니다. 값이 90%로 유지되는 것을 확인할 수 있습니다.\nvalue+percent total : 현재 단계의 값을 전체 단계의 총합에 대한 비율로 표시합니다. 첫번째 단계는 전체 단계의 총합으로 나눈 비율이며 와 같이 아래와 같이 계산됩니다. \\[21\\% = \\frac{100 (첫번째 단계 값)}{468.51 (전체 단계 총합)}\\]"
  },
  {
    "objectID": "docs/blog/posts/2023/10/2023-10-08-plotly-line-shape/index.html",
    "href": "docs/blog/posts/2023/10/2023-10-08-plotly-line-shape/index.html",
    "title": "Plotly line, shape 그리기",
    "section": "",
    "text": "Ploty로 line과 shape를 그리는 방법을 정리합니다.\n\n\nadd_shape함수로 line을 그리는 코드입니다.\n\nimport plotly.graph_objects as go\n\nfig = go.Figure()\n\n# Create scatter trace of text labels\nfig.add_trace(go.Scatter(\n    x=[6, 6, 6],\n    y=[1, 3, 5],\n    text=[\"Line\",\n          \"Dashed Line\",\n          \"Dotted Line\"],\n    mode=\"text\",\n))\n\n# Add shapes\nfig.add_shape(type=\"line\",\n    x0=1, y0=1, x1=5, y1=1,\n    line=dict(color=\"RoyalBlue\",width=3)\n)\n\nfig.add_shape(type=\"line\",\n    x0=1, y0=3, x1=5, y1=3,\n    line=dict(\n        color=\"LightSeaGreen\",\n        width=4,\n        dash=\"dashdot\",\n    )\n)\n\nfig.add_shape(type=\"line\",\n    x0=1, y0=5, x1=5, y1=5,\n    line=dict(\n        color=\"MediumPurple\",\n        width=4,\n        dash=\"dot\",\n    )\n)\n\n# Set axes ranges\nfig.update_xaxes(range=[0, 8])\nfig.update_yaxes(range=[0, 6])\n\nfig.show()\n\n\n                                                \n\n\nline은 add_shape함수를 사용합니다. 라인의 스타일은 line변수에 딕셔너리 형식으로 정보를 전달합니다. 딕셔너리의 dash는 라인의 형태를 결정하고 dashdot, dot, line으로 설정할 수 있습니다.\n\n\n\nadd_shape함수로 직사각형을 그리는 코드입니다.\n\nimport plotly.graph_objects as go\n\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(\n    x=[1.5, 4.5],\n    y=[0.75, 0.75],\n    text=[\"Unfilled Rectangle\", \"Filled Rectangle\"],\n    mode=\"text\",\n))\n\n# Set axes properties\nfig.update_xaxes(range=[0, 7], showgrid=False)\nfig.update_yaxes(range=[0, 3.5])\n\n# Add shapes\nfig.add_shape(type=\"rect\",\n    x0=1, y0=1, x1=2, y1=3,\n    line=dict(color=\"RoyalBlue\"),\n)\nfig.add_shape(type=\"rect\",\n    x0=3, y0=1, x1=6, y1=2,\n    line=dict(\n        color=\"RoyalBlue\",\n        width=2,\n    ),\n    fillcolor=\"LightSkyBlue\",\n)\nfig.update_shapes(dict(xref='x', yref='y'))\nfig.show()\n\n\n                                                \n\n\n이번엔 add_shape함수에 type으로 전달하는 정보를 rect로 전달해서 직사각형을 만들었습니다. 내부를 색으로 채울때는 fillcolor를 사용했습니다.\n\n\n\n차트에 라인을 이용하여 원하는 위치를 지정하는 경우 투명도를 조정해서 차트의 정보를 유지하면 라인을 그릴 수 있습니다.\n\nimport plotly.graph_objects as go\n\nfig = go.Figure()\n\nfig.add_shape(type=\"line\",\n    x0=1, y0=1, x1=5, y1=1,\n    opacity=0.5,\n    line=dict(\n        color=\"MediumPurple\",\n        width=4,\n        dash=\"dot\",\n    )\n)\n\nfig.add_shape(type=\"line\",\n    x0=1, y0=2, x1=5, y1=2,\n    opacity=0.7,\n    line=dict(\n        color=\"MediumPurple\",\n        width=4,\n        dash=\"dot\",\n    )\n)\n\n# Set axes ranges\nfig.update_xaxes(range=[0, 6])\nfig.update_yaxes(range=[0, 3])\n\nfig.show()\n\n\n                                                \n\n\nadd_shape함수에 opacity를 추가로 전달합니다. opacity가 1인 경우 투명도가 없이 표시되며 opacity가 0인 경우 완전히 투명합니다."
  },
  {
    "objectID": "docs/blog/posts/2023/10/2023-10-02-hover-mode/index.html",
    "href": "docs/blog/posts/2023/10/2023-10-02-hover-mode/index.html",
    "title": "Plotly Hover 설정하기",
    "section": "",
    "text": "Plotly에서는 데이터의 정보를 쉽게 확인할 수 있는 Hover 레이블을 제공합니다. Hover 레이블은 정보를 확인할 데이터의 위치로 마우스를 이동하면 정보를 표시하는 기능입니다.\n\nimport plotly.express as px\n\ndf = px.data.gapminder().query(\"continent=='Oceania'\")\n\nfig = px.line(df, x=\"year\", y=\"lifeExp\", color=\"country\", title=\"layout.hovermode='closest' (the default)\")\nfig.update_traces(mode=\"markers+lines\")\n\nfig.show()\n\n\n                                                \n\n\n테스트를위해서 line 차트를 생성합니다. Hover 레이블에 대한 설정이 없을 경우 layout.hovermode='closest으로 설정되고 가장 가까운 데이터를 Hover 레이블로 표시합니다.\n\n\n선택된 X축 또는 Y축에 해당하는 데이터를 함게 표시하는 Hover 레이블 모드를 정리합니다.\n\nimport plotly.express as px\n\ndf = px.data.gapminder().query(\"continent=='Oceania'\")\n\nfig = px.line(df, x=\"year\", y=\"lifeExp\", color=\"country\", title=\"layout.hovermode='x'\")\nfig.update_traces(mode=\"markers+lines\", hovertemplate=None)\nfig.update_layout(hovermode=\"x\")\n\nfig.show()\n\n\n                                                \n\n\nupdate_layout에 hovermode를 x로 정의하면 선택된 X축에 위치한 데이터 벙보를 호버 레이블로 표시합니다.\nx unified형식은 X, Y정보를 Hover 레이블에 추가합니다. 그리고 각 축의 값을 표시하기위한 점선도 함께 추가됩니다.\n\nimport plotly.express as px\n\ndf = px.data.gapminder().query(\"continent=='Oceania'\")\n\nfig = px.line(df, x=\"year\", y=\"lifeExp\", color=\"country\", title=\"layout.hovermode='x unified'\")\nfig.update_traces(mode=\"markers+lines\", hovertemplate=None)\nfig.update_layout(hovermode=\"x unified\")\n\nfig.show()\n\n\n                                                \n\n\n위의 실행결과를 확인하면 점선이 생성되는 것을 확인할 수 있습니다.\n\n\n\nHover 레이블에 표시할 데이터를 설정하는 방법을 정리합니다.\n\nimport plotly.express as px\n\ndf_2007 = px.data.gapminder().query(\"year==2007\")\ndf.head()\n\n\n\n\n\n  \n    \n      \n      country\n      continent\n      year\n      lifeExp\n      pop\n      gdpPercap\n      iso_alpha\n      iso_num\n    \n  \n  \n    \n      60\n      Australia\n      Oceania\n      1952\n      69.12\n      8691212\n      10039.59564\n      AUS\n      36\n    \n    \n      61\n      Australia\n      Oceania\n      1957\n      70.33\n      9712569\n      10949.64959\n      AUS\n      36\n    \n    \n      62\n      Australia\n      Oceania\n      1962\n      70.93\n      10794968\n      12217.22686\n      AUS\n      36\n    \n    \n      63\n      Australia\n      Oceania\n      1967\n      71.10\n      11872264\n      14526.12465\n      AUS\n      36\n    \n    \n      64\n      Australia\n      Oceania\n      1972\n      71.93\n      13177000\n      16788.62948\n      AUS\n      36\n    \n  \n\n\n\n\ngapminder데이터를 gdpPercap을 x축, lifeExp를 y축으로 설정하여 데이터를 표시합니다.\n\nfig = px.scatter(df_2007, x=\"gdpPercap\", y=\"lifeExp\", log_x=True,\n                 hover_name=\"country\",)\nfig.show()\n\n\n                                                \n\n\n위의 그래프에서 임의의 데이터의 위치로 마우스를 이동하면 기본적으로 그래프에 사용한 x축과 y축의 데이터인 gdpPercap과 lifeExp정보만 Hover 레이블에 표시됨을 알 수 있습니다.\n\nfig = px.scatter(df_2007, x=\"gdpPercap\", y=\"lifeExp\", log_x=True,\n                 hover_name=\"country\", hover_data=[\"continent\", \"pop\"])\n\nfig.show()\n\n\n                                                \n\n\n위의 차트에는 hover_data를 통해서 추가 정보를 확인할 컬럼명을 전달하였습니다. 이제 추가정보가 Hover 레이블에 표시됩니다."
  },
  {
    "objectID": "docs/blog/posts/2023/10/2023-10-04-disabling-pan-n-zoom/index.html",
    "href": "docs/blog/posts/2023/10/2023-10-04-disabling-pan-n-zoom/index.html",
    "title": "Plotly Zoom Disable하기",
    "section": "",
    "text": "Plotly Zoom Disable하기\nPlotly 차트는 마우스를 이용하여 원하는 위치를 쉽게 확대할 수 있습니다. 하지만 모바일 환경에서 차트를 표시하거나 영역의 확대를 하나의 축의 방향으로 확대하 필요한 경우 Zoom Disable을 사용할 수 있습니다.\n\nimport plotly.express as px\ndf = px.data.iris()\n\nfig = px.scatter(df, x=\"sepal_width\", y=\"sepal_length\", facet_col=\"species\")\nfig.update_xaxes(fixedrange=True)\n\nfig.show()\n\n\n                                                \n\n\nx축에 대한 Zoom을 disable 하기 위해서 update_xaxes()함수에 fixedrange값을 true로 설정했습니다.\n모든 축에 대해서 fixedrange를 사용하면 어떤 방향으로도 Zoom이 수행되지 않습니다.\n\nimport plotly.express as px\ndf = px.data.iris()\n\nfig = px.scatter(df, x=\"sepal_width\", y=\"sepal_length\", facet_col=\"species\")\nfig.update_xaxes(fixedrange=True)\nfig.update_yaxes(fixedrange=True)\n\nfig.show()"
  },
  {
    "objectID": "docs/blog/posts/2023/10/2023-10-04-xtick-angle/index.html",
    "href": "docs/blog/posts/2023/10/2023-10-04-xtick-angle/index.html",
    "title": "Plotly 차트의 축 tick 회전 및 폰트 변경하기",
    "section": "",
    "text": "Plotly x축 tick 회전시키기\n차트의 축에 표시될 tick 값의 길이가 긴 경우 tick을 회전 시키는 것이 좋습니다.\n\nimport plotly.graph_objects as go\n\nfig = go.Figure(go.Scatter(\n    mode = \"lines+markers\",\n    y = [4, 1, 3, 1, 10, 3, 7, 11, 5, 7, 8, 2],\n    x = [ \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\",]))\n\nfig.show()\n\n\n                                                \n\n\nx축과 y축의 tick의 fontsize와 회전을 적용합니다.\n\nfig = go.Figure(go.Scatter(\n    mode = \"lines+markers\",\n    y = [4, 1, 3, 1, 10, 3, 7, 11, 5, 7, 8, 2],\n    x = [ \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\",]))\n\nfig.update_xaxes(\n        tickangle = 70,\n        tickfont = {\"size\": 14},\n        title_text = \"Month\",\n        title_font = {\"size\": 20},\n        title_standoff = 25)\n\nfig.update_yaxes(\n        title_text = \"Temperature\",\n        title_standoff = 25)\n\n\n                                                \n\n\ntickfont로 x축의 tick의 글자크기를 설정합니다. title_font는 축 타이틀의 크기를 결정하고 title_standoff는 축과 title사이의 거리를 결정합니다."
  },
  {
    "objectID": "docs/blog/posts/2023/10/2023-10-09-github-template/index.html",
    "href": "docs/blog/posts/2023/10/2023-10-09-github-template/index.html",
    "title": "Github Pull Request 템플릿 적용하기",
    "section": "",
    "text": "Github의 Pull Request 진행 시 적용되는 문서 탬플릿을 작성하고 적용하는 방법을 정리합니다.\n\n\nPull Request 탬플릿을 작성하기 위해서 탬플릿 문서를 작성합니다.\n\n문서 생성을 위해서 위와 같이 Github 레포지토리 상단의 Add file > Create new file 버튼을 선택합니다.\n\n버튼을 선택하면 파일의 내용과 파일명을 저장할 수 있는 Text Editor 페이지가 위와 같이 생성됩니다. 탬플릿 문서를 특정 위치에 저장하기 위해서 레포지토리 루트폴더에 .github 폴더를 만들고 이 폴더에 pull_request_template.md 파일을 생성합니다.\n이 문서 내부에 작성하는 내용은 Pull Request(PR) 을 작성하는 commiter가 PR을 작성하면 이 템플릿의 내용을 Text Editor에 자동으로 추가됩니다. 필요한 내용을 모두 작성했다면 Commit chages 버튼을 눌러 수정한 내용을 저장합니다.\n\n\n\nPR을 생성할 때 새롭게 작성한 템플릿 내용이 작성되었는 지 확인합니다. 이를 위해서 기본 레포지토리를 Fork해서 수정 내용을 작성하고 Pull Requset 를 진행합니다.\n\n위와같이 PR을 생성하면 템플릿으로 작성한 내용이 기본적으로 제공됩니다. 레포지토리에 머지를 요청할 때 전달할 내용과 확인이 필요한 내용을 탬플릿으로 작성하면 PR리뷰에 필요한 내용을 잘 확인할 수 있습니다."
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-22-plotly-3dplot/index.html",
    "href": "docs/blog/posts/2023/09/2023-09-22-plotly-3dplot/index.html",
    "title": "Plotly 3D Plot만들기",
    "section": "",
    "text": "Plotly 3D Plot을 생성하기 위해서 x와 y축을 linespace로 생성합니다. x와 y에는 각각 0 부터 80과 0 부터 60까지를 80개로 나누어진 값이 저장됩니다. x와 y에 저장된 값으로 x,y평면을 생성하기 위해서 meshgrid를 사용합니다. xGrid와 yGrid에는 xy평면의 좌표에 해당하는 값이 ndarray형식으로 저장됩니다.\n\nimport plotly.graph_objects as go\nimport numpy as np\n\nN=80\n\nx = np.linspace(0, 80, N)\ny = np.linspace(0, 60, N)\nxGrid, yGrid = np.meshgrid(x, y)\nprint(f\"xGrid Type: {type(xGrid)}\")\nprint(f\"xGrid.shape: {xGrid.shape},  yGrid.shape: {yGrid.shape}\")\n\nxGrid Type: <class 'numpy.ndarray'>\nxGrid.shape: (80, 80),  yGrid.shape: (80, 80)\n\n\nxy평면에 설정할 z값을 sin함수 값으로 설정하고 크기는 20으로 설정합니다. go.Surface를 이용해서 3D Plot을 생성하고 update_layout으로 title과 크기를 결정합니다.\n\nimport plotly.graph_objects as go\nimport numpy as np\n\nN=80\n\nx = np.linspace(0, 80, N)\ny = np.linspace(0, 60, N)\nxGrid, yGrid = np.meshgrid(x, y)\nz = 20*np.sin(xGrid/40*2*np.pi)\n\nfig = go.Figure(data=[go.Surface(x=x, y=y, z=z, colorscale='YlGnBu', showscale=False)])\nfig.update_layout(\n    title_text='3D Plot',\n    height=800,\n    width=780\n)\nfig.show()\n\n\n                                                \n\n\n\n\n3D Plot을 subplot에 사용하기 위해서 make_subplots을 사용합니다. specs는 subplot의 옵션을 설정을 위해 사용됩니다. 설정은 생성한 subplot의 갯수와 동일하게 적용하며 type변수로 subplot의 형태를 결정합니다. type에 사용가능한 설정의 종류는 아래와 같습니다.\n\n“xy”: 막대형 등에 대한 2D 데카르트 하위 플롯 유형입니다. 유형이 지정되지 않은 경우 이것이 기본값입니다.\n“scene”: 3d, cone 등에 대한 3D 데카르트 서브플롯\n“polar”: 분산형, 막대형 등에 대한 극형 서브플롯\n“ternary”: Ternary subplot\n“mapbox”: Mapbox subplot\n\n\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\nimport numpy as np\n\n# Initialize figure with 4 3D subplots\nfig = make_subplots(\n    rows=2, cols=2,\n    specs=[[{'type': 'scene'}, {'type': 'scene'}],\n           [{'type': 'scene'}, {'type': 'scene'}]])\n\nN=80\nx = np.linspace(0, 80, N)\ny = np.linspace(0, 60, N)\nxGrid, yGrid = np.meshgrid(y, x)\nz = 20*np.sin(xGrid/40*2*np.pi) + np.sin(xGrid/40*2*np.pi)\n\n# adding surfaces to subplots.\nfig.add_trace(\n    go.Surface(x=x, y=y, z=z, colorscale='Viridis', showscale=False),\n    row=1, col=1)\n\nfig.add_trace(\n    go.Surface(x=x, y=y, z=z, colorscale='RdBu', showscale=False),\n    row=1, col=2)\n\nfig.add_trace(\n    go.Surface(x=x, y=y, z=z, colorscale='YlOrRd', showscale=False),\n    row=2, col=1)\n\nfig.add_trace(\n    go.Surface(x=x, y=y, z=z, colorscale='YlGnBu', showscale=False),\n    row=2, col=2)\n\nfig.update_layout(\n    title_text='3D subplots with different colorscales',\n    height=800,\n    width=780\n)\n\nfig.show()\n\n\n                                                \n\n\nsubplot에 추가할 그래프가 모두 3D Plot이기 때문에 make_subplots의 spec의 type은 모두 scene으로 설정했습니다. subplot에 3D Plot을 추가하기 위해서 fig.add_trace()함수를 사용하고 색상을 다르게 설정하기 위해서 colorscale을 다르게 설정했습니다."
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-16-date-index/index.html",
    "href": "docs/blog/posts/2023/09/2023-09-16-date-index/index.html",
    "title": "날짜 범위 index 만들기",
    "section": "",
    "text": "날짜 정보를 index로 넣는 경우 날짜 정보를 가진 series를 만들어야 합니다 이 때 data_range()함수를 사용할 수 있습니다. 연습을 위해서 과목의 성적을 갖는 데이터프레임을 만듭니다.\n\nimport pandas as pd\n\ndf = pd.DataFrame({'Math' : [100,80,80,70,90],\n                   'Science' : [80,100,20,100,70],\n                   'English' : [70,80,90,59,100]})\ndf\n\n\n\n\n\n  \n    \n      \n      Math\n      Science\n      English\n    \n  \n  \n    \n      0\n      100\n      80\n      70\n    \n    \n      1\n      80\n      100\n      80\n    \n    \n      2\n      80\n      20\n      90\n    \n    \n      3\n      70\n      100\n      59\n    \n    \n      4\n      90\n      70\n      100\n    \n  \n\n\n\n\n각 과목의 점수는 시험이 진행된 시간으로 작성되는 것이 데이터 관리에 편리할 것 같습니다. data_range()함수로 날짜 인덱스를 만듭니다.\n\npd.date_range('2021-01-01', '2021-01-10')\n\nDatetimeIndex(['2021-01-01', '2021-01-02', '2021-01-03', '2021-01-04',\n               '2021-01-05', '2021-01-06', '2021-01-07', '2021-01-08',\n               '2021-01-09', '2021-01-10'],\n              dtype='datetime64[ns]', freq='D')\n\n\nDatetimeIndex를 생성했습니다. 날짜 인덱스가 데이터보다 많이 생성됐습니다. 정해진 갯수의 날짜를 생성합니다.\n\npd.date_range(start='1/1/2018', periods=5)\n\nDatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04',\n               '2018-01-05'],\n              dtype='datetime64[ns]', freq='D')\n\n\n이제 5개의 날짜 인덱스가 생성되었습니다. 각 과목의 점수는 2달마다 진행된다고 합니다. 인덱스가 시작날짜부터 2달 간격으로 늘어가면 좋겠습니다.\n\npd.date_range(start='1/1/2021', periods=5, freq='2M')\n\nDatetimeIndex(['2021-01-31', '2021-03-31', '2021-05-31', '2021-07-31',\n               '2021-09-30'],\n              dtype='datetime64[ns]', freq='2M')\n\n\n함수에서 제공하는 freq를 이용해서 2달 간격 날짜 인덱스를 생성했습니다. frequency로 지원하는 시간정보는 [여기]서 확인할 수 있습니다.\n\n\n\nhttps://pandas.pydata.org/docs/reference/api/pandas.date_range.html"
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-23-plotly-dynamic-table/index.html",
    "href": "docs/blog/posts/2023/09/2023-09-23-plotly-dynamic-table/index.html",
    "title": "Plotly Rador 차트 만들기",
    "section": "",
    "text": "Radot차트는 로 다양한 변수나 차원의 데이터를 비교하거나 시각화할 때 유용합니다. 여러개의 다차원 데이터를 한번에 비교할 수 있도록 도와줍니다. 하지만 차트에 사용되는 변수가 다양해지는 경우 데이터 해석이 어려울 수 있기 때문에 변수 갯수가 작고 상대적 비교를 강조하고 싶은 경우 사용할 수 있습니다.\n\nimport plotly.express as px\nimport pandas as pd\ndf = pd.DataFrame(dict(\n    r=[1, 5, 2, 2, 3],\n    theta=['processing cost','mechanical properties','chemical stability',\n           'thermal stability', 'device integration']))\ndf\n\n\n\n\n\n  \n    \n      \n      r\n      theta\n    \n  \n  \n    \n      0\n      1\n      processing cost\n    \n    \n      1\n      5\n      mechanical properties\n    \n    \n      2\n      2\n      chemical stability\n    \n    \n      3\n      2\n      thermal stability\n    \n    \n      4\n      3\n      device integration\n    \n  \n\n\n\n\n\nimport plotly.offline as pyo\nimport plotly.graph_objs as go\n\n# jupyterbook offline 변경하기\npyo.init_notebook_mode()\n\nRador차트를 그리기 위해서 테스트 데이터를 생성합니다. 데이터는 r과 theta 컬럼을 갖고 있으며 각각 길이와 각도를 정의합니다. 총 5개의 특징을 0 부터 5의 값으로 표현합니다.\n\nfig = px.line_polar(df, r='r', theta='theta', line_close=True)\nfig.show()\n\n\n                                                \n\n\n생성된 Polar 차트는 theta의 값이 동일한 각도로 표시되었습니다. 데이터 영역 내부를 채우기 외해서 update_traces의 fill옵션을 사용합니다. toself로 내부에 색칠할 수 있습니다.\n\nimport plotly.express as px\nimport pandas as pd\ndf = pd.DataFrame(dict(\n    r=[1, 5, 2, 2, 3],\n    theta=['processing cost','mechanical properties','chemical stability',\n           'thermal stability', 'device integration']))\nfig = px.line_polar(df, r='r', theta='theta', line_close=True)\nfig.update_traces(fill='toself')\nfig.show()\n\n\n                                                \n\n\n\n\nScatterploar 차트로 Rador차트를 그리면 각 데이터에 점을 표시할 수 있습니다. Scatterpolar으로 차트를 그릴 경우 go.Figure의 data에 Scatterpolar 그래프 생성결과를 전달하여 차트를 생성합니다.\n\nimport plotly.graph_objects as go\n\nfig = go.Figure()\n\nfig.add_trace(go.Scatterpolar(\n  r=[1, 5, 2, 2, 3],\n  theta=['processing cost','mechanical properties','chemical stability', 'thermal stability',\n           'device integration'],\n  fill='toself',\n  name='Product A'))\n\nfig.update_layout(\n  showlegend=True\n)\n\nfig.show()\n\n\n                                                \n\n\n\n\n\nRador차트에 여러 개의 정보를 같이 표시하는 방법을 정리합니다.\n\nimport plotly.graph_objects as go\n\ncategories = ['processing cost','mechanical properties','chemical stability',\n              'thermal stability', 'device integration']\n\nfig = go.Figure()\n\nfig.add_trace(go.Scatterpolar(\n      r=[1, 5, 2, 2, 3],\n      theta=categories,\n      fill='toself',\n      name='Product A'\n))\nfig.add_trace(go.Scatterpolar(\n      r=[4, 3, 2.5, 1, 2],\n      theta=categories,\n      fill='toself',\n      name='Product B'\n))\n\nfig.update_layout(\n  polar=dict(\n    radialaxis=dict(\n      visible=True,\n      range=[0, 5]\n    )),\n  showlegend=True\n)\n\nfig.show()\n\n\n                                                \n\n\n여러개의 데이터를 하나의 차트에 추가할 때는 add_trace를 사용합니다. Product A와 Product B의 정보가 추가되었습니다. 각 데이터가 어떤 정보인지 확인할 수 있도록 name옵션을 전달했습니다. update_layout의 showlegend가 true로 설정되어야 legend가 출력됨을 참고하세요."
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-30-plotly-axis-style/index.html",
    "href": "docs/blog/posts/2023/09/2023-09-30-plotly-axis-style/index.html",
    "title": "Plotly Axis 포멧 변경하기",
    "section": "",
    "text": "Plotly 차트의 포멧을 변경하는 방법을 정리합니다.\n\nimport plotly.graph_objects as go\n\nfig = go.Figure(go.Scatter(\n    x = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],\n    y = [0.28, 0.285, 0.37, 0.56, 0.69, 0.79, 0.78, 0.77, 0.74, 0.62, 0.45, 0.39]\n))\n\nfig.update_layout(yaxis_tickformat = '%')\nfig.show()\n\n\n                                                \n\n\ny축으로 표시하는 정보가 %단위인 경우 yaxis_tickformat으로 정보를 전달할 수 있습니다.\n\n\n소숫점 표현 방식을 지정하여 표현하는 방법을 정리합니다. yaxis_tickformat에 소수점 이하 한자리만 표현하기 위해서 .1%로 표현을 변경했습니다.\n\nimport plotly.graph_objects as go\n\nfig = go.Figure(go.Scatter(\n    x = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],\n    y = [0.28, 0.285, 0.37, 0.56, 0.69, 0.79, 0.78, 0.77, 0.74, 0.62, 0.45, 0.39]\n))\n\nfig.update_layout(\n  yaxis_tickformat = '.1%')\nfig.show()\n\n\n                                                \n\n\n\n\n\n두 개의 Y축을 이용해서 그래프를 표현하는 방법을 정리합니다.\n\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\n# Create figure with secondary y-axis\nfig = make_subplots(specs=[[{\"secondary_y\": True}]])\n\n# Add traces\nfig.add_trace(\n    go.Scatter(x=[1, 2, 3], y=[40, 50, 60], name=\"yaxis data (left)\"),\n    secondary_y=False,\n)\n\nfig.add_trace(\n    go.Scatter(x=[2, 3, 4], y=[4, 5, 6], name=\"yaxis2 data (right)\"),\n    secondary_y=True,\n)\n\n# Add figure title\nfig.update_layout(\n    title_text=\"Double Y Axis Example\"\n)\n\n# Set x-axis title\nfig.update_xaxes(title_text=\"xaxis title\")\n\n# Set y-axes titles\nfig.update_yaxes(title_text=\"<b>primary</b> yaxis title\", secondary_y=False)\nfig.update_yaxes(title_text=\"<b>secondary</b> yaxis title\", secondary_y=True)\n\nfig.show()\n\n\n                                                \n\n\n두 분째 Y축을 사용하기 위해서 make_subplots의 spec에 secondary_y값을 True로 설정합니다.\n그래프를 add_trace로 추가 시 secondary_y정보를 이용해서 오른쪽 Y축을 사용할 데이터를 결정합니다.\n각 그래프의 name을 yaxis data (left)와 yaxis2 data (right)와 같이 작성해서 어떤 Y축을 참고해야 하는 지 전달합니다."
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-28-styling-marker/index.html",
    "href": "docs/blog/posts/2023/09/2023-09-28-styling-marker/index.html",
    "title": "Plotly 마커 모양 변경하기",
    "section": "",
    "text": "Plotly 차트의 마커 모양을 변경하면 집중이 필요한 데이터를 강조할 수 있습니다. 마커의 색과 모양을 변경하는 방법을 정리합니다.\n\nimport plotly.express as px\n\ndf = px.data.iris()\ndf.sample(3)\n\n\n\n\n\n  \n    \n      \n      sepal_length\n      sepal_width\n      petal_length\n      petal_width\n      species\n      species_id\n    \n  \n  \n    \n      103\n      6.3\n      2.9\n      5.6\n      1.8\n      virginica\n      3\n    \n    \n      148\n      6.2\n      3.4\n      5.4\n      2.3\n      virginica\n      3\n    \n    \n      147\n      6.5\n      3.0\n      5.2\n      2.0\n      virginica\n      3\n    \n  \n\n\n\n\n연습을 위해 사용할 데이터프레임을 알아봅니다. 붓꽃(Irises)의 종류를 구분하기 위해 사용되는 iris데이터입니다. 케글 데이터 셋에서 데이터셋의 자세한 내용을 확인할 수 있습니다.\n\ndf['species'].unique()\n\narray(['setosa', 'versicolor', 'virginica'], dtype=object)\n\n\n데이터셋의 3가지 붓꽃 종의 이름을 확인하기 위해서 species 컬럼의 중복을 제외한 unique한 데이터를 확인합니다. setosa, versicolor, virginica의 3개의 붓꽃 종이 있음을 알 수 있습니다.\n\n\nscatter plot을 이용해서 데이터를 시각화합니다. x축과 y축에는 각각 sepal_width와 sepal_length를 사용합니다.\n\nfig = px.scatter(df, x=\"sepal_width\", y=\"sepal_length\", color=\"species\")\n\nfig.show()\n\n\n                                                \n\n\ncolor에 species컬럼 정보를 전달해서 3개의 종의 데이터가 서로다른 색으로 시각화됐습니다.\n\n\n\nupdate_traces에 marker에 마커 모양을 위한 딕셔너리 정보를 전달하여 마커의 모양을 변경합니다.\n\nfig = px.scatter(df, x=\"sepal_width\", y=\"sepal_length\", color=\"species\")\n\nfig.update_traces(marker=dict(size=12,\n                              line=dict(width=2,\n                                        color='DarkSlateGrey')),\n                  selector=dict(mode='markers'))\nfig.show()\n\n\n                                                \n\n\n마커의 size는 12이고 마커의 외곽선은 width는 2, 색은 DarkSlateGrey로 수정했습니다. selector에는 mode를 markers로 전달해서 style이 적용될 영역을 선택합니다.\n\n\n\n\nimport plotly.graph_objects as go\n\nfig = go.Figure()\n\nfig.add_trace(\n  go.Scatter(\n    mode = 'markers', # line, markers, text\n    x = [1,2,3],\n    y = [10,20,30],\n    marker=dict(\n        color='LightSkyBlue',\n        size=20,\n        line=dict(\n            color='MediumPurple',\n            width=2)\n      ),\n    name= 'Marker Style 1'\n  )\n)\n\nfig.add_trace(\n  go.Scatter(\n    mode = 'lines',\n    x = [1,2,3],\n    y = [30,20,10],\n    line=dict(\n      color='Blue',\n      width=5\n    ),\n    name= 'Marker Style 2'\n  )\n)\n\nfig.add_trace(\n  go.Scatter(\n    mode = 'markers',\n    x = [1,2,3],\n    y = [50,50,50],\n    marker=dict(\n        color='Orange',\n        size=20,\n        line=dict(\n            color='Blue',\n            width=2)\n      ),\n    name= 'Marker Style 3'\n  )\n)\n\n\n\nfig.show()\n\n\n                                                \n\n\n차트에 여러 개의 그래프를 추가하기 위해서 add_trace()를 사용했습니다. 각 그래프의 마커 스타일은 go.Scatter함수 mode에 전달한 정보에 따라 다릅니다.\nmarkers모드인 경우 마커의 sytle을 marker로 전달한 정보로 변경합니다. line모드의 경우 line옵션에 style정보를 전달합니다."
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-11-pandas-merge/index.html",
    "href": "docs/blog/posts/2023/09/2023-09-11-pandas-merge/index.html",
    "title": "Pandas 데이터프레임 머지",
    "section": "",
    "text": "병합은 서로다른 데이터프레임 객체에 동일하게 존재하는 값을 통해 양쪽 데이터를 연관 지어 하나의 데이터프레임으로 모델링할 수 있는 유용한 방법입니다. 연습을 위해서 데이터를 준비합니다.\nYahoo Finance에서는 미국뿐 아니라 한국 주식에 대한 정보를 제공합니다. KOSPI주식 정보를 csv형태로 저장해서 데이터프레임 머지 연습에 사용할께요. Yahoo Finance로 이동해서 historica l data 탭을 선택합니다.\n\nHistorical Data 를 선택하면 위와 같이 KOSPI 에 대한 시계열 데이터를 얻을 수 있습니다. download를 눌러 다운로드하여 저장합니다. 혹은 [KS11.csv]에서 다운로드 하세요.\n\n\ncsv파일을 불러와서 데이터프레임 형태를 확인합니다. 시계열데이터의 경우 날짜정보를 데이터프레임의 index로 사용하면 편리합니다. data컬럼을 index로 설정합니다.\n\nimport pandas as pd\nkospi = pd.read_csv(\"./^KS11.csv\", index_col ='Date')\nkospi.head()\n\n\n\n\n\n  \n    \n      \n      Open\n      High\n      Low\n      Close\n      Adj Close\n      Volume\n    \n    \n      Date\n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2022-09-13\n      2418.590088\n      2453.949951\n      2418.590088\n      2449.540039\n      2449.540039\n      366900\n    \n    \n      2022-09-14\n      2390.469971\n      2418.419922\n      2381.500000\n      2411.419922\n      2411.419922\n      461300\n    \n    \n      2022-09-15\n      2416.010010\n      2421.629883\n      2401.830078\n      2401.830078\n      2401.830078\n      423900\n    \n    \n      2022-09-16\n      2387.560059\n      2395.100098\n      2371.110107\n      2382.780029\n      2382.780029\n      440300\n    \n    \n      2022-09-19\n      2388.729980\n      2389.850098\n      2352.760010\n      2355.659912\n      2355.659912\n      403700\n    \n  \n\n\n\n\n날짜정보가 index로 설정된 데이터프레임을 생성했습니다. 이제 연결을 위한 새로운 데이터프레임을 생성합니다. 데이트 프레임을 연결할 정보를 Ticker라는 컬럼으로 설정하고 기존 데이터프레임의 Volume컬럼을 추가합니다.\n\nkospi_volume = pd.DataFrame ({'Ticker': 'kospi', 'Volume' : kospi['Volume']})\nkospi_volume.head()\n\n\n\n\n\n  \n    \n      \n      Ticker\n      Volume\n    \n    \n      Date\n      \n      \n    \n  \n  \n    \n      2022-09-13\n      kospi\n      366900\n    \n    \n      2022-09-14\n      kospi\n      461300\n    \n    \n      2022-09-15\n      kospi\n      423900\n    \n    \n      2022-09-16\n      kospi\n      440300\n    \n    \n      2022-09-19\n      kospi\n      403700\n    \n  \n\n\n\n\n2개의 데이터프레임이 함께 갖는 컬럼인 ’Ticker’를 통해서 병합을 진행하고 이를 통해서 Volume정보를 추가하려고 합니다. 올바르게 동작하는 지 확인하기 위해서 기존 데이터프레임의 Volume 컬럼을 삭제합니다.\n\nkospi['Ticker'] = 'kospi'\nkospi.pop('Volume')\nkospi.head()\n\n\n\n\n\n  \n    \n      \n      Open\n      High\n      Low\n      Close\n      Adj Close\n      Ticker\n    \n    \n      Date\n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2022-09-13\n      2418.590088\n      2453.949951\n      2418.590088\n      2449.540039\n      2449.540039\n      kospi\n    \n    \n      2022-09-14\n      2390.469971\n      2418.419922\n      2381.500000\n      2411.419922\n      2411.419922\n      kospi\n    \n    \n      2022-09-15\n      2416.010010\n      2421.629883\n      2401.830078\n      2401.830078\n      2401.830078\n      kospi\n    \n    \n      2022-09-16\n      2387.560059\n      2395.100098\n      2371.110107\n      2382.780029\n      2382.780029\n      kospi\n    \n    \n      2022-09-19\n      2388.729980\n      2389.850098\n      2352.760010\n      2355.659912\n      2355.659912\n      kospi\n    \n  \n\n\n\n\nVolume컬럼이 삭제되었으니 병합을 진행합니다. pd.merge()함수를 사용하고 공통 컬럼인 Ticker컬럼을 전달합니다.\n\nmerged_df = pd.merge(kospi, kospi_volume, on='Ticker')\nmerged_df.head()\n\n\n\n\n\n  \n    \n      \n      Open\n      High\n      Low\n      Close\n      Adj Close\n      Ticker\n      Volume\n    \n  \n  \n    \n      0\n      2418.590088\n      2453.949951\n      2418.590088\n      2449.540039\n      2449.540039\n      kospi\n      366900\n    \n    \n      1\n      2418.590088\n      2453.949951\n      2418.590088\n      2449.540039\n      2449.540039\n      kospi\n      461300\n    \n    \n      2\n      2418.590088\n      2453.949951\n      2418.590088\n      2449.540039\n      2449.540039\n      kospi\n      423900\n    \n    \n      3\n      2418.590088\n      2453.949951\n      2418.590088\n      2449.540039\n      2449.540039\n      kospi\n      440300\n    \n    \n      4\n      2418.590088\n      2453.949951\n      2418.590088\n      2449.540039\n      2449.540039\n      kospi\n      403700\n    \n  \n\n\n\n\n이제 새로운 merged_df 데이터프레임은 2개의 데이터프레임을 연결하여 Volume정보를 추가 하였습니다."
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-21-plotly-histogram/index.html",
    "href": "docs/blog/posts/2023/09/2023-09-21-plotly-histogram/index.html",
    "title": "Plotly Histogram Plot만들기",
    "section": "",
    "text": "tips데이터는 고객 정보와 고객이 지불한 금액과 팁을 표시한 데이터입니다.\n\nimport plotly.express as px\ndf = px.data.tips()\ndf.head(3)\n\n\n\n\n\n  \n    \n      \n      total_bill\n      tip\n      sex\n      smoker\n      day\n      time\n      size\n    \n  \n  \n    \n      0\n      16.99\n      1.01\n      Female\n      No\n      Sun\n      Dinner\n      2\n    \n    \n      1\n      10.34\n      1.66\n      Male\n      No\n      Sun\n      Dinner\n      3\n    \n    \n      2\n      21.01\n      3.50\n      Male\n      No\n      Sun\n      Dinner\n      3\n    \n  \n\n\n\n\n\n\n’total_bill’에 대한 histogram을 표시합니다. 시간별 차이를 비교하기 위해서 facet_row에 time정보를 전달합니다.\n\nfig = px.histogram(df, x=\"total_bill\", facet_row=\"time\")\nfig.show()\n\n\n                                                \n\n\n히스토그램의 막대 갯수는 nbins로 수정합니다.\n\nfig = px.histogram(df, x=\"total_bill\", nbins=100)\nfig.show()"
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-14-Dataframe-all-NaN/index.html",
    "href": "docs/blog/posts/2023/09/2023-09-14-Dataframe-all-NaN/index.html",
    "title": "Pandas 모든 컬럼이 NaN일 때만 삭제하기",
    "section": "",
    "text": "pandas에서는 NaN의 값을 갖는 데이터를 누락된 데이터라고 합니다. NaN값은 해당 인덱스 레이블에 값이 없음을 의미합니다. 아래와 같이 NaN값을 가지는 데이터프레임을 생성하고 NaN으로 처리된 없는 값을 채우는 방법을 확인 해봅니다.\n\n\n테스트를 위해서 데이터를 생성합니다.\n\nimport pandas as pd\nimport numpy as np\n\ndf = pd.DataFrame(\n  np.arange(0, 30).reshape(10,3),\n  columns=['a','b','c'])\ndf\n\n\n\n\n\n  \n    \n      \n      a\n      b\n      c\n    \n  \n  \n    \n      0\n      0\n      1\n      2\n    \n    \n      1\n      3\n      4\n      5\n    \n    \n      2\n      6\n      7\n      8\n    \n    \n      3\n      9\n      10\n      11\n    \n    \n      4\n      12\n      13\n      14\n    \n    \n      5\n      15\n      16\n      17\n    \n    \n      6\n      18\n      19\n      20\n    \n    \n      7\n      21\n      22\n      23\n    \n    \n      8\n      24\n      25\n      26\n    \n    \n      9\n      27\n      28\n      29\n    \n  \n\n\n\n\nnumpy라이브러리로 0 부터 29까지 숫자를 생성하고 reshape()함수로 차원을 10, 3으로 변경합니다. 10개의 열과 3개의 컬럼을 갖는 형태로 변경되었습니다. 데이터프레임의 컬럼은 a, b, c로 리스트를 전달했습니다.\n\ndf.loc[[0,7]] = np.NaN\ndf\n\n\n\n\n\n  \n    \n      \n      a\n      b\n      c\n    \n  \n  \n    \n      0\n      NaN\n      NaN\n      NaN\n    \n    \n      1\n      3.0\n      4.0\n      5.0\n    \n    \n      2\n      6.0\n      7.0\n      8.0\n    \n    \n      3\n      9.0\n      10.0\n      11.0\n    \n    \n      4\n      12.0\n      13.0\n      14.0\n    \n    \n      5\n      15.0\n      16.0\n      17.0\n    \n    \n      6\n      18.0\n      19.0\n      20.0\n    \n    \n      7\n      NaN\n      NaN\n      NaN\n    \n    \n      8\n      24.0\n      25.0\n      26.0\n    \n    \n      9\n      27.0\n      28.0\n      29.0\n    \n  \n\n\n\n\n데이터프레임에 NaN을 추가하기 위해서 np.NaN을 사용했습니다. 위치는 0, 7번째 열에 추가하기 위해 df.log[[0, 7]] = np.NaN을 사용합니다.\n\ndf[(df > 10) & (df < 13)] = np.NaN\ndf\n\n\n\n\n\n  \n    \n      \n      a\n      b\n      c\n    \n  \n  \n    \n      0\n      NaN\n      NaN\n      NaN\n    \n    \n      1\n      3.0\n      4.0\n      5.0\n    \n    \n      2\n      6.0\n      7.0\n      8.0\n    \n    \n      3\n      9.0\n      10.0\n      NaN\n    \n    \n      4\n      NaN\n      13.0\n      14.0\n    \n    \n      5\n      15.0\n      16.0\n      17.0\n    \n    \n      6\n      18.0\n      19.0\n      20.0\n    \n    \n      7\n      NaN\n      NaN\n      NaN\n    \n    \n      8\n      24.0\n      25.0\n      26.0\n    \n    \n      9\n      27.0\n      28.0\n      29.0\n    \n  \n\n\n\n\n전체 컬럼이 NaN일 때만 삭제되는 지 확인하기 위해서 일부 컬럼에만 NaN이 있는 경우도 만들겠습니다. df[(df > 10) & (df < 13)] = np.NaN는 데이터프레임의 값이 10보다 크고 13보다 작은 위치에 NaN이 추가되었습니다.\n\ndf.loc[9, 'b'] = np.NAN\ndf\n\n\n\n\n\n  \n    \n      \n      a\n      b\n      c\n    \n  \n  \n    \n      0\n      NaN\n      NaN\n      NaN\n    \n    \n      1\n      3.0\n      4.0\n      5.0\n    \n    \n      2\n      6.0\n      7.0\n      8.0\n    \n    \n      3\n      9.0\n      10.0\n      NaN\n    \n    \n      4\n      NaN\n      13.0\n      14.0\n    \n    \n      5\n      15.0\n      16.0\n      17.0\n    \n    \n      6\n      18.0\n      19.0\n      20.0\n    \n    \n      7\n      NaN\n      NaN\n      NaN\n    \n    \n      8\n      24.0\n      25.0\n      26.0\n    \n    \n      9\n      27.0\n      NaN\n      29.0\n    \n  \n\n\n\n\n이제 컬럼정보와 index정보를 모두 이용해서 데이터를 수정합니다. 데이터프레임의 index가 9이고 컬럼이 b인 위치에 NaN을 추가합니다.\n\n\n\n데이터가 없는 NaN를 찾기 위해서는 isnull()을 사용합니다. isnull()을 사용하면 데이터프레임에서NaN으로 표시된 위치를 True로 표시한 데이터프레임을 반환합니다.\n\ndf.isnull()\n\n\n\n\n\n  \n    \n      \n      a\n      b\n      c\n    \n  \n  \n    \n      0\n      True\n      True\n      True\n    \n    \n      1\n      False\n      False\n      False\n    \n    \n      2\n      False\n      False\n      False\n    \n    \n      3\n      False\n      False\n      True\n    \n    \n      4\n      True\n      False\n      False\n    \n    \n      5\n      False\n      False\n      False\n    \n    \n      6\n      False\n      False\n      False\n    \n    \n      7\n      True\n      True\n      True\n    \n    \n      8\n      False\n      False\n      False\n    \n    \n      9\n      False\n      True\n      False\n    \n  \n\n\n\n\n데이터프레임 중 NaN으로 표시된 부분이 True로 설정되었습니다.\n\n\n\n데이터 프레임에 .dropna()가 사용되면 NaN값이 하나 이상 있는 모은 로우가 삭제됩니다.\n\ndf.dropna()\n\n\n\n\n\n  \n    \n      \n      a\n      b\n      c\n    \n  \n  \n    \n      1\n      3.0\n      4.0\n      5.0\n    \n    \n      2\n      6.0\n      7.0\n      8.0\n    \n    \n      5\n      15.0\n      16.0\n      17.0\n    \n    \n      6\n      18.0\n      19.0\n      20.0\n    \n    \n      8\n      24.0\n      25.0\n      26.0\n    \n  \n\n\n\n\nNaN을 포함하는 0, 3, 4, 7, 9 열이 삭제되었습니다. 모든값이 NaN인 로우만 삭제하고 싶을 경우에는 how=‘all’ 파라메터를 사용합니다.\n\ndf.dropna(how = 'all')\n\n\n\n\n\n  \n    \n      \n      a\n      b\n      c\n    \n  \n  \n    \n      1\n      3.0\n      4.0\n      5.0\n    \n    \n      2\n      6.0\n      7.0\n      8.0\n    \n    \n      3\n      9.0\n      10.0\n      NaN\n    \n    \n      4\n      NaN\n      13.0\n      14.0\n    \n    \n      5\n      15.0\n      16.0\n      17.0\n    \n    \n      6\n      18.0\n      19.0\n      20.0\n    \n    \n      8\n      24.0\n      25.0\n      26.0\n    \n    \n      9\n      27.0\n      NaN\n      29.0\n    \n  \n\n\n\n\n이번에는 모든 열이 NaN정보를 갖는 7번 열이 삭제되었습니다. 이제 컬럼 방향으로 모두 NaN인 경우를 알아봅니다. 컬럼이 모두 NaN이라면 해당 컬럼에 해당하는 정보를 사용할 수 없으니 삭제하는 것이 좋습니다.\n하지만 사용하고 있던 데이터가 공통으로 사용하는 원본 데이터프레임이라면 모두 NaN인 컬럼을 제외하여 새로운 데이터프레임을 생성하는 것이 더 좋을 수 있습니다.\n테스트를 위한 데이터프레임을 만들 때 컬럼이 모두 NaN인 경우는 없었습니다. 테스트를 위해 모든 컬럼값이 NaN인 경우를 만들어봅니다.\n\ndf['d'] = np.NaN\ndf\n\n\n\n\n\n  \n    \n      \n      a\n      b\n      c\n      d\n    \n  \n  \n    \n      0\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      1\n      3.0\n      4.0\n      5.0\n      NaN\n    \n    \n      2\n      6.0\n      7.0\n      8.0\n      NaN\n    \n    \n      3\n      9.0\n      10.0\n      NaN\n      NaN\n    \n    \n      4\n      NaN\n      13.0\n      14.0\n      NaN\n    \n    \n      5\n      15.0\n      16.0\n      17.0\n      NaN\n    \n    \n      6\n      18.0\n      19.0\n      20.0\n      NaN\n    \n    \n      7\n      NaN\n      NaN\n      NaN\n      NaN\n    \n    \n      8\n      24.0\n      25.0\n      26.0\n      NaN\n    \n    \n      9\n      27.0\n      NaN\n      29.0\n      NaN\n    \n  \n\n\n\n\n데이터프레임에 모든 값이 NaN인 d 컬럼을 추가했습니다. 이제 컬럼방향으로 모두 NaN값을 가진 컬럼만 삭제합니다.\n\ndf.dropna(how='all', axis=1)\n\n\n\n\n\n  \n    \n      \n      a\n      b\n      c\n    \n  \n  \n    \n      0\n      NaN\n      NaN\n      NaN\n    \n    \n      1\n      3.0\n      4.0\n      5.0\n    \n    \n      2\n      6.0\n      7.0\n      8.0\n    \n    \n      3\n      9.0\n      10.0\n      NaN\n    \n    \n      4\n      NaN\n      13.0\n      14.0\n    \n    \n      5\n      15.0\n      16.0\n      17.0\n    \n    \n      6\n      18.0\n      19.0\n      20.0\n    \n    \n      7\n      NaN\n      NaN\n      NaN\n    \n    \n      8\n      24.0\n      25.0\n      26.0\n    \n    \n      9\n      27.0\n      NaN\n      29.0\n    \n  \n\n\n\n\naxis를 1로 사용했습니다. 숫자는 데이터프레임의 shape의 순서 인덱스며 1은 컬럼 방향을 의미합니다.\n\ndf.shape\n\n(10, 4)\n\n\n테스트에 사용한 데이터프레임의 shape를 확인하면 첫번째 정보는 열, 두 번째 정보는 컬럼의 크기를 의미합니다. 위의 코드에서 사용한 axis는 shape의 2번째 인덱스 방향인 컬럼방향을 의미합니다.\n\n\n\n\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.dropna.html"
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-25-plotly-timeseries-daterange/index.html",
    "href": "docs/blog/posts/2023/09/2023-09-25-plotly-timeseries-daterange/index.html",
    "title": "Plotly Time Series 날짜 범위 UI 사용하기",
    "section": "",
    "text": "시계열 데이터의 날짜 범위를 잘 사용하면 데이터의 의미를 다양한 관점으로 이해할 수 있습니다. 시계열 데이터를 시각화 시 날짜 범위를 설정하는 방법을 정리합니다.\n\nimport plotly.express as px\n\nimport pandas as pd\ndf = pd.read_csv('https://raw.githubusercontent.com/plotly/datasets/master/finance-charts-apple.csv')\ndisplay(df.head(3))\ndisplay(df.tail(3))\n\n\n\n\n\n  \n    \n      \n      Date\n      AAPL.Open\n      AAPL.High\n      AAPL.Low\n      AAPL.Close\n      AAPL.Volume\n      AAPL.Adjusted\n      dn\n      mavg\n      up\n      direction\n    \n  \n  \n    \n      0\n      2015-02-17\n      127.489998\n      128.880005\n      126.919998\n      127.830002\n      63152400\n      122.905254\n      106.741052\n      117.927667\n      129.114281\n      Increasing\n    \n    \n      1\n      2015-02-18\n      127.629997\n      128.779999\n      127.449997\n      128.720001\n      44891700\n      123.760965\n      107.842423\n      118.940333\n      130.038244\n      Increasing\n    \n    \n      2\n      2015-02-19\n      128.479996\n      129.029999\n      128.330002\n      128.449997\n      37362400\n      123.501363\n      108.894245\n      119.889167\n      130.884089\n      Decreasing\n    \n  \n\n\n\n\n\n\n\n\n  \n    \n      \n      Date\n      AAPL.Open\n      AAPL.High\n      AAPL.Low\n      AAPL.Close\n      AAPL.Volume\n      AAPL.Adjusted\n      dn\n      mavg\n      up\n      direction\n    \n  \n  \n    \n      503\n      2017-02-14\n      133.470001\n      135.089996\n      133.250000\n      135.020004\n      32815500\n      135.020004\n      115.175718\n      125.953499\n      136.731280\n      Increasing\n    \n    \n      504\n      2017-02-15\n      135.520004\n      136.270004\n      134.619995\n      135.509995\n      35501600\n      135.509995\n      115.545035\n      126.723499\n      137.901963\n      Decreasing\n    \n    \n      505\n      2017-02-16\n      135.669998\n      135.899994\n      134.839996\n      135.350006\n      22118000\n      135.350006\n      116.203299\n      127.504333\n      138.805366\n      Decreasing\n    \n  \n\n\n\n\n시계열 데이터를 시각화하기 위해서 불러온 데이터를 확인합니다. 데이터프레임의 Date컬럼에 날짜 정보가 있습니다. 처음과 마지막 3개의 데이터를 확인하면 데이터에 2015년 2월부터 2017년 2월까지의 데이터가 있는 것을 알 수 있습니다.\n나머지 컬럼은 Apple 주가의 상한가, 하한가, 종가등의 정보를 갖습니다. Apple의 상한가를 Line plot으로 확인합니다.\n\nfig = px.line(df, x='Date', y='AAPL.High')\nfig.show()\n\n\n                                                \n\n\n2015년 부터 2017년까지의 주가 정보를 Line plot으로 시각화 했습니다.\n\n\n시계열 데이터를 좀 더 자세히 확인하기 위해서 x축으로 표시할 날짜 범위를 지정합니다. 2016년 3월부터 2016년 7월까지의 정보를 확인하기 위해서 날짜범위를 지정합니다.\n\nfig = px.line(df, x='Date', y='AAPL.High', range_x=['2016-03-01','2016-7-31'])\nfig.show()\n\n\n                                                \n\n\n전체 데이터에서 range_x로 지정한 날짜 사이의 데이터만 Line plot에 표시됩니다.\n\n\n\n슬라이더 UI를 사용하면 사용자가 원하는 날짜 범위를 설정하고 날짜를 변경할 수 있습니다.\n\nfig = px.line(df, x='Date', y='AAPL.High', title='Time Series with Rangeslider')\n\nfig.update_xaxes(rangeslider_visible=True)\nfig.show()\n\n\n                                                \n\n\nupdate_xaxes()에 rangeslider_visible 옵션을 True로 선택해서 x축에 슬라이더 UI를 사용합니다.\n사용자는 그래프 하단의 날짜 범위 슬라이더의 양쪽 끝의 흰색 바를 이동하여 날짜 범위를 변경합니다. 슬라이더 내부를 선택한 상태로 이동시켜 날짜 범위의 위치를 변경할 수 있습니다.\n\n\n\n특정한 날짜 범위를 버튼으로 제공해서 사용자가 일정 날짜 범위로 데이터를 확인할 수 있습니다. update_xaxes()함수로 x축에 대한 설정을 변경합니다. rangeselector옵션에 버튼에 대한 정보를 딕셔너리 형태로 전달해서 버튼을 생성합니다.\nbuttons을 생성하기 위한 정보는 buttons API문서에서 확인할 수 있습니다. step을 통해서 날짜범위위의 단위를 결정하고 count를 통해서 범위횟수, stepmode는 현재 시점에서 어떤 방향로 날짜범위를 결정합니다.\n\nfig = px.line(df, x='Date', y='AAPL.High', title='Time Series with Range Slider and Selectors')\n\nfig.update_xaxes(\n    rangeslider_visible=True,\n    rangeselector=dict(\n        buttons=list([\n            dict(count=1, label=\"1m\", step=\"month\", stepmode=\"backward\"),\n            dict(count=6, label=\"6m\", step=\"month\", stepmode=\"backward\"),\n            dict(count=1, label=\"YTD\", step=\"year\", stepmode=\"todate\"),\n            dict(count=1, label=\"1y\", step=\"year\", stepmode=\"backward\"),\n            dict(step=\"all\")\n        ])\n    )\n)\nfig.show()\n\n\n                                                \n\n\n그래프 위쪽의 날짜 버튼을 선택해서 슬라이더 UI가 어떻게 변경되는 지 확인해보세요."
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-14-panda-dulicated-data/index.html",
    "href": "docs/blog/posts/2023/09/2023-09-14-panda-dulicated-data/index.html",
    "title": "Pandas 중복 데이터 제거하기",
    "section": "",
    "text": "데이터프레임에는 중복 데이터가 존재할 수 있습니다. 중복 데이터가 계산 결과에 영향을 주는 의도된 데이터가 아니라면 중복 데이터를 적절하게 처리하는 것이 필요할 수 있습니다. 현업에서 진행하게 된다면 이 과정은 데이터에 대해서 이해한 업무 담당자와 확인이 필요합니다. 중복데이터 연습을 위해서 데이터프레임을 생성합니다.\n\nimport pandas as pd\n\ndf_duplicated = pd.DataFrame({'city': ['seoul']*3 + ['busan']*2,\n                              'num' : ['02'] *3 + ['051']*2})\ndf_duplicated\n\n\n\n\n\n  \n    \n      \n      city\n      num\n    \n  \n  \n    \n      0\n      seoul\n      02\n    \n    \n      1\n      seoul\n      02\n    \n    \n      2\n      seoul\n      02\n    \n    \n      3\n      busan\n      051\n    \n    \n      4\n      busan\n      051\n    \n  \n\n\n\n\n도시 이름에 맞는 지역번호를 정보로 저장하는 데이터프레임으로 생성합니다. city 컬럼 정보를 이용하여 지역번호를 확인하기 위해 데이터프레임을 사용한다면 city정보가 중복될 필요가 없습니다. 중복되는 데이터를 정리할 수 있습니다. 중복된 열정보는 duplicated()함수를 이용하여 확인합니다.\n\ndf_duplicated.duplicated()\n\n0    False\n1     True\n2     True\n3    False\n4     True\ndtype: bool\n\n\n중복된 열정보를 갖는 boolean Series가 리턴되었습니다. 이 정보를 이용해서 중복된 열을 제거합니다. 중복된 열은 drop_duplicates()함수를 사용합니다. 함수의 [API정보]를 확인하면 keep 파라메터를 이용해서 어떤 위치의 중복열을 True로 표시할지 결정합니다.\n\n마지막 중복열을 제외한 모든 열을 True로 정의하기 위해서 keep 파라메터를 last로 전달합니다. 기본은 first값을 갖는군요.\n\ndf_duplicated.drop_duplicates(keep='last')\n\n\n\n\n\n  \n    \n      \n      city\n      num\n    \n  \n  \n    \n      2\n      seoul\n      02\n    \n    \n      4\n      busan\n      051\n    \n  \n\n\n\n\n중복된 열의 마지막 열만 남고 중복된 열이 삭제되었습니다. 아직 df_duplicated 데이터프레임의 정보는 변경되지 않았다는 것을 주의해야합니다.\n\ndf_duplicated\n\n\n\n\n\n  \n    \n      \n      city\n      num\n    \n  \n  \n    \n      0\n      seoul\n      02\n    \n    \n      1\n      seoul\n      02\n    \n    \n      2\n      seoul\n      02\n    \n    \n      3\n      busan\n      051\n    \n    \n      4\n      busan\n      051\n    \n  \n\n\n\n\n데이터프레임을 변경하는 경우 변수에 결과값을 다시 전달하거나 함수가 inplace파라메터를 지원해서 데이터프레임을 바로 수정할 수 있는 지 확인해야 합니다.\n\ndf = df_duplicated.drop_duplicates(keep='last')\ndf\n\n\n\n\n\n  \n    \n      \n      city\n      num\n    \n  \n  \n    \n      2\n      seoul\n      02\n    \n    \n      4\n      busan\n      051\n    \n  \n\n\n\n\n이제 중복을 제거한 데이터프레임의 city컬럼의 정보가 busan인 열을 선택합니다. 선택을 위해서 df에 boolean indexing결과를 전달합니다.\n\ndf[df['city'] == 'busan']\n\n\n\n\n\n  \n    \n      \n      city\n      num\n    \n  \n  \n    \n      4\n      busan\n      051\n    \n  \n\n\n\n\n\n\n\nhttps://pandas.pydata.org/docs/reference/api/pandas.DataFrame.duplicated.html"
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-12-markdown/index.html",
    "href": "docs/blog/posts/2023/09/2023-09-12-markdown/index.html",
    "title": "Markdown문법 정리하기",
    "section": "",
    "text": "마크다운은 텍스트를 이용해 문서를 작성하는 도구입니다. 일반 텍스트를 이용해서 Table, 링크 등 다양한 문서형태를 작성할 수 있습니다. Quart는 Pandoc을 기반으로 하고 있으며 Markdown으로 문서를 작성합니다. 자주 사용하는 Markdown 문법을 정리합니다.\n\n\n텍스트의 형태를 변경하는 다양한 문법을 확인합니다.\n\n\n\n\n\n\n\nMarkdown Syntax\nOutput\n\n\n\n\n*italics*, **bold**, ***bold italics***\nitalics, bold, bold italics\n\n\nsuperscript^2^ / subscript~2~\nsuperscript2 / subscript2\n\n\n~~strikethrough~~\nstrikethrough\n\n\n\n\n\n\n링크에 보일 글자와 함께 링크정보를 표시합니다.\n# 링크 연결\n<https://quarto.org>\n[Quarto](https://quarto/org)\nhttps://quarto.org Quarto\n# 이미지표시\n![Caption](cover.png)\n\n\n\n\nMarkdown으로 table을 구성하는 방법을 정리합니다.\n| Right | Left | Default | Center |\n|------:|:-----|---------|:------:|\n|   12  |  12  |    12   |    12  |\n|  123  |  123 |   123   |   123  |\n|    1  |    1 |     1   |     1  |\n\n\n\nRight\nLeft\nDefault\nCenter\n\n\n\n\n12\n12\n12\n12\n\n\n123\n123\n123\n123\n\n\n1\n1\n1\n1\n\n\n\n\n\n\nQuarto에서 소스코드를 추가하는 방법을 정리힙니다.\n코드의 처음과 마지막에 ```를 이용해서 코드 영역을 표시합니다.\n```\ncode\n```\n코드에 맞는 언어를 표시하여 언어별 코드 하이라이트를 적용할 수 있습니다.\n```python\n1 + 1\n```\nPandoc에서 지원하는 하이라이트 기능을 사용할 수 있습니다. 140 언어 지원 정보를 확인하세요. 만약 지원하는 언어가 없다면 default를 사용할 수 있습니다.\n```default\ncode\n```\n\n\n\n$ 구분기호를 이용하여 인라인 수식을 추가하고 $$ 구분기호를 이용하여 수식만 표현할 수 있습니다.\n\n\n\n\n\n\n\nMarkdown Syntax\nOutput\n\n\n\n\n인라인 수식: $E = mc^{2}$\n인라인 수식: \\(E=mc^{2}\\)\n\n\n수식 단독표현:\n\n$$E = mc^{2}$$\n수식 단독표현:\n\\[E = mc^{2}\\]\n\n\n\n\n\n\nQuarto는 Mermaid와 Graphviz 다이어그램을 지원합니다. 플로우차트, 시퀀스 다이어그램, 스테이트 다이어그램, 간트차트등을 그릴 수 있습니다. Mermaid를 이용해서 플로우 차트를 생성합니다.\n\n```{mermaid}\nflowchart LR\n  A[입력] --> B(전처리)\n  B --> C{판단로직}\n  C --> D[성공]\n  C --> E[실패]\n```\n\n\n\nflowchart LR\n  A[입력] --> B(전처리)\n  B --> C{판단로직}\n  C --> D[성공]\n  C --> E[실패]\n\n\n\n\n\n\n\n\n\n\n\n문서 내부에 동영상을 연결할 수 있습니다. {{< video >}} 를 이용해서 유튜브 동영상은 연결할 수 있습니다.\n{{< video https://www.youtube.com/embed/wo9vZccmqwc >}}\n\n\n\n\nHTML의 div 블럭을 만들 수 있습니다. class 정보를 border로 정의합니다.\n::: {#special .border}\nclass를 \"border\"로 정의한 div block으로 변환됩니다.\n:::\nQuarto를 렌터링하고 나면 아래의 HTML 코드로 변경됩니다.\n<div id=\"special\" class=\"border\">\n  <p>class를 \"border\"로 정의한 div block으로 변환됩니다.</p>\n</div>\n대괄호 []로 표현된 문자열은 span으로 변환됩니다.\n[테스트 *SPAN* 코드입니다.]{.class key=\"val\"}\n<span class=\"class\" data-key=\"val\">\n  테스트 <em>SPAN</em> 코드입니다.\n</span>\n\n\n\n\nhttps://quarto.org/docs/authoring/markdown-basics.html"
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-17-plotly-bubblechart/index.html",
    "href": "docs/blog/posts/2023/09/2023-09-17-plotly-bubblechart/index.html",
    "title": "Plotly Bubble chart 만들기",
    "section": "",
    "text": "Plotly로 Bubble 차트 만들기를 연습합니다. 연습을 위한 데이터는 Plotly Express에서 제공하는 데이터를 사용합니다. gapminder.org에서 제공하는 데이터를 데이터프레임으로 불러옵니다. 데이터 구조를 확인하기 위해서 처음 3개의 데이터를 확인하겠습니다.\n\nimport plotly.express as px\ndf = px.data.gapminder()\ndf.sample(3)\n\n\n\n\n\n  \n    \n      \n      country\n      continent\n      year\n      lifeExp\n      pop\n      gdpPercap\n      iso_alpha\n      iso_num\n    \n  \n  \n    \n      1157\n      Oman\n      Asia\n      1977\n      57.367\n      1004533\n      11848.343920\n      OMN\n      512\n    \n    \n      1626\n      Uruguay\n      Americas\n      1982\n      70.805\n      2953997\n      6920.223051\n      URY\n      858\n    \n    \n      1652\n      Vietnam\n      Asia\n      1992\n      67.662\n      69940728\n      989.023149\n      VNM\n      704\n    \n  \n\n\n\n\n여러 국가에 대한 정보를 연도별로 정리한 데이터입니다. 대한민국에 대한 데이터를 살펴보면 좀 더 의미있고 재미있는 시각화가 될 것 같습니다. country컬럼의 값이 Korea, Rep.인 데이터만 추출합니다.\n\ndf_korea = df[df['country'] == 'Korea, Rep.']\ndisplay(df_korea.head(3))\ndisplay(df['year'].describe())\n\n\n\n\n\n  \n    \n      \n      country\n      continent\n      year\n      lifeExp\n      pop\n      gdpPercap\n      iso_alpha\n      iso_num\n    \n  \n  \n    \n      840\n      Korea, Rep.\n      Asia\n      1952\n      47.453\n      20947571\n      1030.592226\n      KOR\n      410\n    \n    \n      841\n      Korea, Rep.\n      Asia\n      1957\n      52.681\n      22611552\n      1487.593537\n      KOR\n      410\n    \n    \n      842\n      Korea, Rep.\n      Asia\n      1962\n      55.292\n      26420307\n      1536.344387\n      KOR\n      410\n    \n  \n\n\n\n\ncount    1704.00000\nmean     1979.50000\nstd        17.26533\nmin      1952.00000\n25%      1965.75000\n50%      1979.50000\n75%      1993.25000\nmax      2007.00000\nName: year, dtype: float64\n\n\n데이터프레임의 year컬럼의 통계정보를 describe()함수로 확인하여 데이터가 1952년 부터 2007년까지 있음을 확인합니다. 버블차트를 이용하여 인구의 변화 양상을 시각화하겠습니다.\n\n\n데이터프레임의 인구를 버블차트로 표현합니다. y축에는 기대수명을 표시하고 scatter 차트를 버블차트로 표현하기 위해서 size에 인구정보를 전달했습니다. 이제 새로운 차트에서는 버블의 크기로 인구를 표시합니다..\n\nimport numpy as np\n\nfig = px.scatter(df.query(\"country== 'Korea, Rep.'\"), x= 'year', y='lifeExp', size=\"pop\")\nfig.show()\n\n\n                                                \n\n\n버블차트를 살펴보면 1950년, 1970년 이후 기대수명이 크게 올라가는 것을 알 수 있습니다. 추가로 버블의 크기를 통해서 인구 증가폭이 2007년에 가까워 지면서 인구수의 변화가 작아짐을 알 수 있습니다.\n\n\n\n버블차트는 버블의 크기와 색상으로 각각 정보를 표현할 수 있습니다. 이번엔 버블에 색상을 추가하여 총 4개의 정보를 표현합니다. 각 컬럼정보gdpPercap은 1인당 GDP를 의미하고 lifeExp는 기대 수명을 의미합니다. 1인당 GDP 변화에 따른 기대수명과 인구를 대륙별로 비교합니다.\n\nfig = px.scatter(df.query(\"year==2007\"), x=\"gdpPercap\", y=\"lifeExp\",\n                  size=\"pop\", color=\"continent\",\n                hover_name=\"country\", log_x=True, size_max=60)\nfig.show()\n\n\n                                                \n\n\n우선 색상으로 대륙별 기대수명과 인구를 비교할 수 있습니다. 초록색의 아프리카 대륙은 좌측 하단에 주로 위치하고 있어 인구수와 기대수명이 낮을 것을 알 수 있습니다. 아시아 국가는 버블의 크기도 다양하고 1인당 GDP도 넓은 분포를 보여주고 1인당 GDP가 높은 국가로는 일본, 한국, 싱가포르등이 있는 것을 알 수 있습니다.\n\n\n\n\nhttps://plotly.com/python/bubble-charts/"
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-10-quarto-callout/index.html",
    "href": "docs/blog/posts/2023/09/2023-09-10-quarto-callout/index.html",
    "title": "Quarto Callout Block",
    "section": "",
    "text": "Quarto를 이용해 문서를 작성하는 과정에서 강조할 내용이 있는 경우 Callout Block을 사용하는 것이 좋습니다. 자산이 작성한 글에 집중이 필요한 내용을 명확하게 나타낼 수 있습니다. 공부한 내용을 정리합니다."
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-10-quarto-callout/index.html#callout-종류",
    "href": "docs/blog/posts/2023/09/2023-09-10-quarto-callout/index.html#callout-종류",
    "title": "Quarto Callout Block",
    "section": "Callout 종류",
    "text": "Callout 종류\nCallout Block은 총 아래의 note, warning, important, tip, caution 5가지 종류를 갖습니다. 실제 어떻게 적용되는지 아래에서 살펴보세요.\n\n\n\n\n\n\nNote\n\n\n\nCallout note 타입을 사용합니다.\n\n\n\n\n\n\n\n\nWarning\n\n\n\nCallout warning 타입을 사용합니다.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nCallout important 타입을 사용합니다.\n\n\n\n\n\n\n\n\nTip\n\n\n\nCallout tip 타입을 사용합니다.\n\n\n\n\n\n\n\n\nDanger\n\n\n\nCallout caution 타입을 사용합니다.\n\n\nMarkdown으로 어떻게 구현하는 지 확인해봅시다. ::: 키워드를 사용했고 Callout Block형식은 {}로 표시합니다.\n::: {.callout-caution}\n# 제목을 추가합니다.\nCallout `caution` 타입을 사용합니다.\n:::\n\n\n\n\n\n\n제목을 추가합니다.\n\n\n\nCallout caution 타입을 사용합니다."
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-10-quarto-callout/index.html#다양한-사용자-설정",
    "href": "docs/blog/posts/2023/09/2023-09-10-quarto-callout/index.html#다양한-사용자-설정",
    "title": "Quarto Callout Block",
    "section": "다양한 사용자 설정",
    "text": "다양한 사용자 설정\n\n제목 추가하기\n아이콘은 유지하고 제목을 변경하고 싶은 경우가 있습니다. 이 경우 header 마크다운을 사용합니다.\n::: {.callout-caution}\n# 제목을 추가합니다.\nCallout `caution` 타입을 사용합니다.\n:::\n\n\n\n\n\n\n제목을 추가합니다.\n\n\n\nCallout caution 타입을 사용합니다.\n\n\n\n\n형태 변경하기\nCallout Block의 외형은 default, simple, minimam 형태를 지원합니다. 각각이 어떻게 표현되는지 알아봅니다.\n\n\n\n\n\n\nDefault 외형\n\n\n\ndefault 외형을 확인합니다.\n\n\n\n\n\n\n\n\nsimple 외형\n\n\n\nsimple 외형을 확인합니다.\n\n\n\n\n\n\n\n\nminimal 외형\n\n\n\nminimal 외형을 확인합니다.\n\n\n코드는 아래와 같이 사용합니다. appearance가 추가되었습니다.\n::: {.callout-note appearance=\"minimal\"}\n# Default 외형\ndefault 외형을 확인합니다.\n:::"
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-19-plotly-scatterplot/index.html",
    "href": "docs/blog/posts/2023/09/2023-09-19-plotly-scatterplot/index.html",
    "title": "Plotly Scatter Plot만들기",
    "section": "",
    "text": "Plotly Scatter Plot을 연습하기 위해서 Plotly Express의 medals_long()데이터를 사용합니다. 국가별로 메달의 종류와 갯수를 저장한 데이터프레임입니다.\n\nimport plotly.express as px\ndf = px.data.medals_long()\ndf\n\n\n\n\n\n  \n    \n      \n      nation\n      medal\n      count\n    \n  \n  \n    \n      0\n      South Korea\n      gold\n      24\n    \n    \n      1\n      China\n      gold\n      10\n    \n    \n      2\n      Canada\n      gold\n      9\n    \n    \n      3\n      South Korea\n      silver\n      13\n    \n    \n      4\n      China\n      silver\n      15\n    \n    \n      5\n      Canada\n      silver\n      12\n    \n    \n      6\n      South Korea\n      bronze\n      11\n    \n    \n      7\n      China\n      bronze\n      8\n    \n    \n      8\n      Canada\n      bronze\n      12\n    \n  \n\n\n\n\nx축에는 국가정보 y축에는 메달의 수가 표시됩니다. color로 데이터를 그룹화하여 표시합니다. scatter plot의 심볼의 모양은 symbol정보로 설정합니다.\n\nfig = px.scatter(df, x=\"nation\", y=\"count\", color=\"medal\", symbol=\"medal\")\nfig.update_traces(marker_size=10)\nfig.show()\n\n\n                                                \n\n\n\n\nScatter Plot의 데이터를 순서대로 표시하기 위해서 scattermode를 group으로 사용할 수 있습니다.\n\npx.scatter(df, y=\"count\", x=\"nation\", color=\"medal\"),\nfig.update_traces(marker_size=10)\nfig.update_layout(scattermode=\"group\")\nfig.show()\n\n\n                                                \n\n\nGroup 내부의 데이터 사이 간격은 scattergap으로 변경합니다.\n\nfig = px.scatter(df, y=\"count\", x=\"nation\", color=\"medal\")\nfig.update_traces(marker_size=10)\nfig.update_layout(scattermode=\"group\", scattergap=0.8)\nfig.show()\n\n\n                                                \n\n\n\n\n\nfacet 옵션을 사용하면 각 데이터 그룹을 하나의 subplot에 표시할 수 있습니다. 연습을 위해서 tips 데이터를 불러옵니다.\n\nimport plotly.express as px\ndf = px.data.tips()\ndf.head(3)\n\n\n\n\n\n  \n    \n      \n      total_bill\n      tip\n      sex\n      smoker\n      day\n      time\n      size\n    \n  \n  \n    \n      0\n      16.99\n      1.01\n      Female\n      No\n      Sun\n      Dinner\n      2\n    \n    \n      1\n      10.34\n      1.66\n      Male\n      No\n      Sun\n      Dinner\n      3\n    \n    \n      2\n      21.01\n      3.50\n      Male\n      No\n      Sun\n      Dinner\n      3\n    \n  \n\n\n\n\ntips데이터는 고객 정보와 고객이 지불한 금액과 팁을 표시한 데이터입니다.\n\nimport plotly.express as px\ndf = px.data.tips()\nfig = px.scatter(df, x=\"total_bill\", y=\"tip\", color=\"smoker\", facet_col=\"sex\", facet_row=\"time\")\nfig.show()\n\n\n                                                \n\n\nfacet_col과 facet_row정보를 설정합니다. sex는 Male과 Female로 구성되어 있기 때문에 2개의 행이 추가됐습니다. facet_row는 time정보로 Dinner와 Lunch를 표시하는 subplot이 생성됐습니다."
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-18-plotly-animation/index.html",
    "href": "docs/blog/posts/2023/09/2023-09-18-plotly-animation/index.html",
    "title": "Plotly Animation 만들기",
    "section": "",
    "text": "Plotly Bubble chart animation 만들기\nBubble차트를 animation으로 표현하는 방법을 정리합니다. 데이터는 gapminder를 사용합니다.\n\nimport plotly.express as px\ndf = px.data.gapminder()\ndf.sample(5)\n\n\n\n\n\n  \n    \n      \n      country\n      continent\n      year\n      lifeExp\n      pop\n      gdpPercap\n      iso_alpha\n      iso_num\n    \n  \n  \n    \n      418\n      Denmark\n      Europe\n      2002\n      77.180\n      5374693\n      32166.500060\n      DNK\n      208\n    \n    \n      706\n      India\n      Asia\n      2002\n      62.879\n      1034172547\n      1746.769454\n      IND\n      356\n    \n    \n      376\n      Croatia\n      Europe\n      1972\n      69.610\n      4225310\n      9164.090127\n      HRV\n      191\n    \n    \n      1105\n      Nicaragua\n      Americas\n      1957\n      45.432\n      1358828\n      3457.415947\n      NIC\n      558\n    \n    \n      1700\n      Zimbabwe\n      Africa\n      1992\n      60.377\n      10704340\n      693.420786\n      ZWE\n      716\n    \n  \n\n\n\n\n데이터를 Animation으로 보여주기 위해서 데이터프레임의 정보를 확인합니다.\n\ndf.info()\n\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 1704 entries, 0 to 1703\nData columns (total 8 columns):\n #   Column     Non-Null Count  Dtype  \n---  ------     --------------  -----  \n 0   country    1704 non-null   object \n 1   continent  1704 non-null   object \n 2   year       1704 non-null   int64  \n 3   lifeExp    1704 non-null   float64\n 4   pop        1704 non-null   int64  \n 5   gdpPercap  1704 non-null   float64\n 6   iso_alpha  1704 non-null   object \n 7   iso_num    1704 non-null   int64  \ndtypes: float64(2), int64(3), object(3)\nmemory usage: 106.6+ KB\n\n\n데이터프레임의 year 컬럼을 이용해서 연도별 흐름을 animation으로 표현할 수 있을 것 같습니다. 좀 더 자세히 year컬럼을 확인합니다.\n\ndisplay(len(df['year'].unique()))\nfig = px.histogram(df, x='year', nbins = 60)\nfig.show()\n\n12\n\n\n\n                                                \n\n\n데이터프레임의 year컬럼은 총 12개의 unique value를 갖고 있습니다. 히스토그램으로 표시하면 5년 단위로 값을 갖는 것을 알 수 있습니다. 이제 year 정보를 이용해서 animation을 구성합니다.\n\nfig = px.scatter(df, x='gdpPercap', y='lifeExp', color='continent', size='pop',\n                hover_name='country', log_x=True, animation_frame='year',\n                 animation_group='country', range_x=[100, 70000], range_y=[25,90])\nfig.show()\n\n\n                                                \n\n\n시간의 흐름에 따라서 x축과 y축에 표시되는 데이터의 위치가 변경됩니다. 데이터가 최초와 최종 animation단계에서 모두 그래프에 표시될 수 있도록 range_x와 range_y를 이용하여 축의 범위를 수정합니다.\n\nfig = px.bar(df, x=\"continent\", y=\"pop\", color=\"continent\", hover_name='country',\n  animation_frame=\"year\", animation_group=\"country\", range_y=[0,4000000000])\nfig.show()\n\n\n                                                \n\n\n위와 같이 Bar차트도 동일하게 animation_frame과 animation_group을 설정하여 시간의 흐름에 따른 인구 변화를 나타낼 수 있습니다. hover_name을 country로 설정해서 animation_group의 country 정보를 확인할 수 있습니다."
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-19-plotly-boxplot/index.html",
    "href": "docs/blog/posts/2023/09/2023-09-19-plotly-boxplot/index.html",
    "title": "Plotly Box Plot만들기",
    "section": "",
    "text": "Plotly Box Plot 만드는 방법을 정리합니다. 데이터는 레스토랑의 tip정보를 저장한 tips를 사용합니다.\n\nimport plotly.express as px\ndf = px.data.tips()\ndf.sample(3)\n\n\n\n\n\n  \n    \n      \n      total_bill\n      tip\n      sex\n      smoker\n      day\n      time\n      size\n    \n  \n  \n    \n      103\n      22.42\n      3.48\n      Female\n      Yes\n      Sat\n      Dinner\n      2\n    \n    \n      193\n      15.48\n      2.02\n      Male\n      Yes\n      Thur\n      Lunch\n      2\n    \n    \n      47\n      32.40\n      6.00\n      Male\n      No\n      Sun\n      Dinner\n      4\n    \n  \n\n\n\n\ntotal_bill 컬럼은 지출한 금액이고 tip은 지출한 팁을 표시하는 것 같습니다. 다음으로 고객의 다양한 특징을 표현하는 컬럼정보와 함께 지출했던 시간 정보가 있습니다. 우선 total_bill의 데이터 분포를 확인하기 위해서 Boxplot을 그려봅니다. 혹시 데이터프레임에 정보가 없는 영역이 있는 지 확인합니다. NaN인 경우 true로 표시하는 isnull()함수의 합계가 모두 0이기 때문에 데이터에 문제가 없습니다.\n\ndf.isnull().sum()\n\ntotal_bill    0\ntip           0\nsex           0\nsmoker        0\nday           0\ntime          0\nsize          0\ndtype: int64\n\n\nBox plot으로 의미있는 데이터를 얻기위해서 위해서 숫자형 데이터가 필요합니다. total_bill, tip, size는 숫자형 데이터임을 알 수 있습니다.\n\ndf.info()\n\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 244 entries, 0 to 243\nData columns (total 7 columns):\n #   Column      Non-Null Count  Dtype  \n---  ------      --------------  -----  \n 0   total_bill  244 non-null    float64\n 1   tip         244 non-null    float64\n 2   sex         244 non-null    object \n 3   smoker      244 non-null    object \n 4   day         244 non-null    object \n 5   time        244 non-null    object \n 6   size        244 non-null    int64  \ndtypes: float64(2), int64(1), object(4)\nmemory usage: 13.5+ KB\n\n\ntotal_bill에 대한 Box plot정보를 표시합니다.\n\nfig = px.box(df, y=\"total_bill\")\nfig.show()\n\n\n                                                \n\n\n\n\n가로로 그래프로 표시할 경우 데이터를 전달하는 축을 x로 변경하여 전달합니다.\n\nfig = px.box(df, x=\"total_bill\")\nfig.show()\n\n\n                                                \n\n\n\n\n\nx축에 요일 정보를 추가해서 Box Plot 결과를 확인합니다. Q1, Q3, 중앙값이 표시됩니다. upper fance와 lower fance를 벗어나는 데이터는 이상치로 생각될 수 있습니다. 40달러 이상의 경우 이상치로 표시되고 있습니다. 저녁식사에 비용이 더 많이 발생했음을 쉽게 알 수 있습니다.\n\nfig = px.box(df, x=\"time\", y=\"total_bill\")\nfig.show()\n\n\n                                                \n\n\n\n\n\nsmoker에 따른 tip차이를 확인하기 위해서 color에 smoker를 전달합니다. x축의 각 요일에 표시되는 tip정보에 smoker정보가 추가되었습니다.\n\nfig = px.box(df, x=\"day\", y=\"tip\", color=\"smoker\")\nfig.show()\n\n\n                                                \n\n\n\n\n\n이번엔 facet_col을 이용해서 sex정보에 따라서 서로다른 그래프 영역으로 표시합니다. x축을 day로 변경하고 y축을 tip으로 변경해서 요일별 tip비용을 time에 따라 그래프를 독립적으로 생성합니다.\n\nfig = px.box(df, x=\"day\", y=\"tip\", color=\"smoker\", facet_col='time')\nfig.show()\n\n\n                                                \n\n\n주말에는 팁이 저녁 식사에 발생했고 토요일에는 이상치가 많이 발생했습니다. 점심식사는 목요일과 금요일에 주로 발생했고 금요일은 점심과 저녁 모두 팁이 발생하는 특징이 있습니다."
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-24-plotly-dash/index.html",
    "href": "docs/blog/posts/2023/09/2023-09-24-plotly-dash/index.html",
    "title": "Plotly Dash로 Table 표시하기",
    "section": "",
    "text": "Dash를 사용하면 Python으로 대화형 웹 어플리케이션을 쉽게 개발할 수 있습니다. 여러개의 대화형 인터페이스를 모아서 데이터 시각화와 데이터 분석을 위한 대화형 대시보드를 생성할 수 있습니다.\nDash를 이용해서 데이터프레임을 인터렉티브 Table로 표시하는 방법을 정리합니다. 테스트를 위한 데이터프레임을 확인합니다.\n\nfrom dash import Dash, html, dash_table\nimport pandas as pd\nimport plotly.offline as pyo\nimport plotly.graph_objs as go\n\n# jupyterbook offline 변경하기\npyo.init_notebook_mode()\n\n# Incorporate data\ndf = pd.read_csv('https://raw.githubusercontent.com/plotly/datasets/master/gapminder2007.csv')\ndf.head(3)\n\n\n\n\n\n  \n    \n      \n      country\n      pop\n      continent\n      lifeExp\n      gdpPercap\n    \n  \n  \n    \n      0\n      Afghanistan\n      31889923.0\n      Asia\n      43.828\n      974.580338\n    \n    \n      1\n      Albania\n      3600523.0\n      Europe\n      76.423\n      5937.029526\n    \n    \n      2\n      Algeria\n      33333216.0\n      Africa\n      72.301\n      6223.367465\n    \n  \n\n\n\n\nDash는 데이터 프레임을 records형식의 딕셔너리로 전달 받습니다. 데이터프레임을 to_dict()함수로 records형식 딕셔너리로 변경합니다. 결과는 하나의 열에 대한 정보가 컬럼명:값의 형태를 갖는 딕셔너리를 리스트의 요소로 갖습니다.\n\ndf.to_dict(orient='records')[:2]\n\n[{'country': 'Afghanistan',\n  'pop': 31889923.0,\n  'continent': 'Asia',\n  'lifeExp': 43.828,\n  'gdpPercap': 974.5803384},\n {'country': 'Albania',\n  'pop': 3600523.0,\n  'continent': 'Europe',\n  'lifeExp': 76.423,\n  'gdpPercap': 5937.029525999999}]\n\n\n결과를 확인하면 리스트에 하나의 열의 정보를 딕셔너리 형태로 표현하는 것을 확인할 수 있습니다.\n\n\napp이라는 이름으로 Dash 인스턴스를 생성합니다. layout함수는 Dash앱의 레이아웃을 결정합니다. html읕 이용해서 HTML 요소를 생성하고 레이아웃에 추가할 수 있습니다. div HTML TAG에 My First App with Data 내용을 추가합니다.\ndash_table은 딕셔너리 데이터를 대화형 표 형식으로 표현합니다. page_size에 10을 설정해서 한 페이지에 표시할 데이터 갯수를 결정합니다. to_dict()함수로 데이터프레임을 전환 시 orient를 record 형태로 설정해야합니다.\n\n# Initialize the app\napp = Dash(__name__)\n\n# App layout\napp.layout = html.Div([\n    html.Div(children='My First App with Data'),\n    dash_table.DataTable(data=df.to_dict(orient = 'records'), page_size=10)])\n\napp.run_server(mode=\"inline\")\napp.run_server(mode='jupyterlab')"
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-11-pandas-datatype-transform/index.html",
    "href": "docs/blog/posts/2023/09/2023-09-11-pandas-datatype-transform/index.html",
    "title": "Pandas 데이터 전처리",
    "section": "",
    "text": "데이터시각화 및 데이터분석을 위해 읽어온 원본 데이터의 데이터 타입이 올바른지 확인하지 않으면 분석과정에 사용하는 다양한 통계적 지표나 필터결과가 오류를 발생합니다. 데이터에 맞는 형식으로 변경되지 않은 데이터프레임을 사용할 때 발생하는 문제점을 확인하고 올바르게 데이터 형식으로 변경하는 과정을 정리합니다.\n\nimport pandas as pd\nimport datetime as dt\n\ndf = pd.DataFrame({\"year\": ['1900','1901','1910','2021', '2023'],\n                   \"n_sales\" : ['10EA', '20EA', '40EA', '100EA', '210EA'],\n                   \"status\" : ['good', 'bad', 'normal', 'bad', 'good']})\ndf\n\n\n\n\n\n  \n    \n      \n      year\n      n_sales\n      status\n    \n  \n  \n    \n      0\n      1900\n      10EA\n      good\n    \n    \n      1\n      1901\n      20EA\n      bad\n    \n    \n      2\n      1910\n      40EA\n      normal\n    \n    \n      3\n      2021\n      100EA\n      bad\n    \n    \n      4\n      2023\n      210EA\n      good\n    \n  \n\n\n\n\n데이터 프레임은 year, n_sales, status 3개의 컬럼을 갖습니다. 각 컬럼이 어떤 데이터 타입인지 확인해볼까요? 데이터프레임의 정보를 보여주는 info()함수로 데이터 타입을 확인합니다.\n\ndf.info()\n\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 5 entries, 0 to 4\nData columns (total 3 columns):\n #   Column   Non-Null Count  Dtype \n---  ------   --------------  ----- \n 0   year     5 non-null      object\n 1   n_sales  5 non-null      object\n 2   status   5 non-null      object\ndtypes: object(3)\nmemory usage: 248.0+ bytes\n\n\n예상했던 데이터 형식과 다릅니다. n_sales는 숫자를 표현하고 있기 때문에 int 타입으로 표현되어야 할 것 같은데 object타입이네요. 데이터 프레임의 통계정보를 보여주는 describe()함수를 사용하면 차이를 알 수 있습니다.\n\ndf['n_sales'].describe()\n\ncount        5\nunique       5\ntop       10EA\nfreq         1\nName: n_sales, dtype: object\n\n\n위의 코드 실행결과에서 확인할 수 있는 것처럼 n_sales컬럼의 통계 정보는 categorical 통계정보가 출력됩니다. 숫자로 표현되지 않아서 예상했던 평균, 표준편차 등의 정보는 알 수 없습니다.\n\n\n데이터에 대한 적절한 전처리가 되지 않는 경우 잘못된 통계정보를 이용할 수 있기 때문에 적절한 전처리가 필요합니다. 위에서 만든 데이터프레임의 각 컬럼에 올바른 데이터타입을 적용해야 합니다.\n\n\n\n\n\n\n  \n    \n      \n      year\n      n_sales\n      status\n    \n  \n  \n    \n      0\n      1900\n      10EA\n      good\n    \n    \n      1\n      1901\n      20EA\n      bad\n    \n    \n      2\n      1910\n      40EA\n      normal\n    \n    \n      3\n      2021\n      100EA\n      bad\n    \n    \n      4\n      2023\n      210EA\n      good\n    \n  \n\n\n\n\n일반적으로 데이터 타입 변경은 데이터에 대한 이해가 필요합니다. year의 경우 날짜를 표현하고 있고 n_sales의 EA는 단위이기 때문에 꼭 필요한 정보가 아니라면 삭제 가능합니다. 이 두 가지 데이터 컬럼은 숫자를 표현하고 있으니 int 타입으로 변경합니다. 마지막 status 컬럼은 명백히 categorical 데이터입니다.\n\ndf['year'] = pd.to_datetime(df['year'])\ndf['n_sales'] = df['n_sales'].str.strip('EA').astype('int')\ndf['status'] = df['status'].astype('category')\n\n위의 to_datatime()과 astype()함수를 이용해서 각 컬럼을 ‘datetime’, ‘int’, ‘categorical’ 타입으로 변경했습니다. 단위를 제거하기 위해서 ‘strip()’ 함수를 사용한 것을 참고하세요.\n\ndf.info()\n\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 5 entries, 0 to 4\nData columns (total 3 columns):\n #   Column   Non-Null Count  Dtype         \n---  ------   --------------  -----         \n 0   year     5 non-null      datetime64[ns]\n 1   n_sales  5 non-null      int64         \n 2   status   5 non-null      category      \ndtypes: category(1), datetime64[ns](1), int64(1)\nmemory usage: 345.0 bytes\n\n\n수정된 데이터 프레임은 올바른 데이터 타입을 갖습니다. 이제 데이터프레임의 통계정보를 확인하겠습니다.\n\ndf['n_sales'].describe()\n\ncount      5.000000\nmean      76.000000\nstd       82.643814\nmin       10.000000\n25%       20.000000\n50%       40.000000\n75%      100.000000\nmax      210.000000\nName: n_sales, dtype: float64\n\n\n이제 예상한 것과 같이 n_sales에 대한 평균, 표준편차 등의 통계정보를 확인할 수 있습니다."
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-16-subplots-in-dash/index.html",
    "href": "docs/blog/posts/2023/09/2023-09-16-subplots-in-dash/index.html",
    "title": "Plotly Treemap 만들기",
    "section": "",
    "text": "Plotly로 Treemap을 만드는 방법을 정리합니다. 트래맵차트는 중첩된 직사각형을 이용하여 계층적 데이터를 효과적으로 시각화 할 수 있습니다. 데이터의 계층구조는 섹터와 상단의 경로표시줄리 이동할 수 있습니다. Plotly Express로 Treemap을 구성합니다.\n\nimport plotly.express as px\nimport pandas as pd\nvendors = [\"Apple\", \"Google\", \"Hoo Bank\", \"Foo Investment\", None, \"Nvidia\", \"Meta\", \"Goo Investment\", \"Moo Bank\", None]\nsectors = [\"Tech\", \"Tech\", \"Finance\", \"Finance\", \"Other\",\n           \"Tech\", \"Tech\", \"Finance\", \"Finance\", \"Other\"]\nregions = [\"North\", \"North\", \"North\", \"North\", \"North\",\n           \"South\", \"South\", \"South\", \"South\", \"South\"]\nsales = [100,100, 200, 100, 100, 200, 200, 100, 200, 100]\ndf = pd.DataFrame(\n    dict(vendors=vendors, sectors=sectors, regions=regions, sales=sales)\n)\ndf[\"location\"] = \"all\" # in order to have a single root node\ndf\n\n\n\n\n\n  \n    \n      \n      vendors\n      sectors\n      regions\n      sales\n      location\n    \n  \n  \n    \n      0\n      Apple\n      Tech\n      North\n      100\n      all\n    \n    \n      1\n      Google\n      Tech\n      North\n      100\n      all\n    \n    \n      2\n      Hoo Bank\n      Finance\n      North\n      200\n      all\n    \n    \n      3\n      Foo Investment\n      Finance\n      North\n      100\n      all\n    \n    \n      4\n      None\n      Other\n      North\n      100\n      all\n    \n    \n      5\n      Nvidia\n      Tech\n      South\n      200\n      all\n    \n    \n      6\n      Meta\n      Tech\n      South\n      200\n      all\n    \n    \n      7\n      Goo Investment\n      Finance\n      South\n      100\n      all\n    \n    \n      8\n      Moo Bank\n      Finance\n      South\n      200\n      all\n    \n    \n      9\n      None\n      Other\n      South\n      100\n      all\n    \n  \n\n\n\n\n테스트를 위해 생성한 데이터프레임의 구조를 알아봅시다. 컬럼은 vendors, sectors, regions, sales, location을 갖고 있습니다. location 컬럼의 모든 값을 all로 변경하여 전체를 표시합니다. 생성하는 Treemap은 sales의 값을 계층정보를 나타내는 컬럼을 sales 정보를 효과적으로 시각화하는 것을 목적으로 합니다. 전체 sales데이터가 region별로 비교하고 각 region안에서 sector별로 비교합니다. sector내무에서는 vencor별 비교를 알 수 있으면 좋겠습니다.\n\nfig = px.treemap(df,\n    path=['location', 'regions', 'sectors',  'vendors'],\n    values='sales')\nfig.update_layout(margin = dict(t=50, l=25, r=25, b=25))\nfig.show()\n\n\n                                                \n\n\n목적에 맞게 시각화한 결과를 확인합니다. 코드를 보면 계층의 순서에 맞춰 컬럼 정보를 path에 전달했습니다. 사각형의 크기를 결정하는 값은 values에 전달하고 sales컬럼 정보를 전달 했습니다. path로 전달된 정보를 확인하면 가장 먼저 location 컬럼이 전달되었습니다.\n가장 큰 사각형에 location 정보가 표시되고 값은 전체 sales정보를 갖습니다. 사각형의 크기는 sales의 값으로 표시됩니다. North의 Finance영역의 크기를 확인하면 각 vendor의 값을 비교할 수 있습니다. Hoo Bank가 ’Foo Investment’보다 sales가 큰 값을 갖는 것을 직관적으로 확인할 수 있습니다. 물론 각 영역을 선택해서 자세한 값을 확인할 수 있습니다.\n\n\n코드에 color 정보를 추가해서 값을 비교하겠습니다. 사각형의 색을 결정할 컬럼을 sales로 선택했습니다. 이제 각 사각형이 색을 갖습니다. 큰 값은 노란색 작은 값은 파란색으로 표시됩니다. South와 North의 sales값을 색으로 확인할 수 있습니다. 사각형의 위치가 멀어서 크기 확인이 어렵다면 색을 추가하여 값의 비교를 쉽게 할 수 있습니다.\n\nfig = px.treemap(df,\n    path=['location', 'regions', 'sectors',  'vendors'],\n    values='sales',\n    color='sales')\nfig.update_layout(margin = dict(t=50, l=25, r=25, b=25))\nfig.show()\n\n\n                                                \n\n\n\n\n\n색상은 다양한 옵션을 지원합니다. color_continuous_scale 정보를 전달해서 다른 색상을 사용합니다. 단색의 경우 색의 채도로 값의 크기를 표현합니다. greens로 정보를 전달해서 초록색의 채도를 이용하여 값을 표현합니다.\n\nfig = px.treemap(df,\n    path=['location', 'regions', 'sectors',  'vendors'],\n    values='sales',\n    color='sales',\n    color_continuous_scale='greens')\nfig.update_layout(margin = dict(t=50, l=25, r=25, b=25))\nfig.show()\n\n\n                                                \n\n\nTreemap은 데이터의 계층 구조와 상대적인 크기를 보여주는 데 사용하면 효과적입니다. 복잡한 계층구조를 시각적으로 표현하기 때문에 쉽게 이해할 수 있으며 비교가 편합니다. 데이터가 어떤 특징을 갖는 지 확인하고 계층적구조를 갖는 다면 Treemap을 이용해서 표현하는 것을 고민하면 좋을 것 같습니다.\n\n\n\n\nhttps://plotly.com/python/treemaps/"
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-13-plotly-subplot/index.html",
    "href": "docs/blog/posts/2023/09/2023-09-13-plotly-subplot/index.html",
    "title": "Plotly Subpolt 만들기",
    "section": "",
    "text": "Python으로 여러개의 그래프를 비교하기 좋은 방법은 subplot을 이용한 방법인 것 같습니다. subplot을 만드는 방법과 subplot의 title작성하는 방법 그리고 subplot들에 대한 전체 title을 넣는 방법도 함께 정리합니다.\nPlotly의 make_subplots함수로 subplot을 구성하고 ploty 그래프를 생성했습니다. add_trace()함수로 생성한 subplot에 그래프를 추가합니다.\n\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\nfig = make_subplots(rows=1, cols = 2)\n\nfig.add_trace(go.Scatter(x=[1, 2, 3], y=[4, 5, 6], name=\"subplot 1\"),\n              row=1, col=1)\nfig.add_trace(go.Scatter(x=[10, 20, 30], y=[100, 200, 300], name=\"subplot 2\"),\n              row=1, col=2)\n\nfig.show()\n\n\n                                                \n\n\n\n\nmake_subplot의 세부 설정을 알아보고 어떻게 변경할 수 있는지 알아봅니다. 하나의 Y축을 2개의 subplot이 공유하도록 shared_yaxes를 사용합니다. 각각의 subplot의 크기는 column_widths로 변경할 수 있습니다. 2개의 subplot사이의 거리는 horizontal_spacing으로 정합니다.\n\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\nfig = make_subplots(\n    rows=1, cols=2,\n    shared_yaxes=True,\n    horizontal_spacing=0.05,\n    column_widths=[0.3, 0.7]\n)\n\n\nfig.add_trace(go.Scatter(x=[1, 2, 3], y=[4, 5, 6], name=\"subplot 1\"),\n              row=1, col=1)\nfig.add_trace(go.Scatter(x=[10, 20, 30], y=[10, 20, 30], name=\"subplot 2\"),\n              row=1, col=2)\n\nfig.show()\n\n\n                                                \n\n\n\n\n\n\nhttps://chancoding.tistory.com/229"
  },
  {
    "objectID": "docs/blog/posts/2023/09/2023-09-22-plotly-lineplot/index.html",
    "href": "docs/blog/posts/2023/09/2023-09-22-plotly-lineplot/index.html",
    "title": "Plotly Line Plot만들기",
    "section": "",
    "text": "Plotly Line plot 연습을 위해서 gapminder 데이터를 사용합니다. 데이터를 살펴보기 위해서 sample 데이터 3개를 확인합니다.\n\nimport plotly.express as px\ndf = px.data.gapminder()\ndf.sample(3)\n\n\n\n\n\n  \n    \n      \n      country\n      continent\n      year\n      lifeExp\n      pop\n      gdpPercap\n      iso_alpha\n      iso_num\n    \n  \n  \n    \n      1666\n      West Bank and Gaza\n      Asia\n      2002\n      72.370\n      3389578\n      4515.487575\n      PSE\n      275\n    \n    \n      1486\n      Switzerland\n      Europe\n      2002\n      80.620\n      7361757\n      34480.957710\n      CHE\n      756\n    \n    \n      1269\n      Reunion\n      Africa\n      1997\n      74.772\n      684810\n      6071.941411\n      REU\n      638\n    \n  \n\n\n\n\n각 국가의 기대수명, 인구 등 여러 정보를 시간에 표시됩니다. Line Plot으로 표시하기에는 많은 데이터이기 때문에 Asia대륙에 대한 정보만 표시하겠습니다.\n\ndf_asia = df.query(\"continent == 'Asia'\")\ndf_asia\n\n\n\n\n\n  \n    \n      \n      country\n      continent\n      year\n      lifeExp\n      pop\n      gdpPercap\n      iso_alpha\n      iso_num\n    \n  \n  \n    \n      0\n      Afghanistan\n      Asia\n      1952\n      28.801\n      8425333\n      779.445314\n      AFG\n      4\n    \n    \n      1\n      Afghanistan\n      Asia\n      1957\n      30.332\n      9240934\n      820.853030\n      AFG\n      4\n    \n    \n      2\n      Afghanistan\n      Asia\n      1962\n      31.997\n      10267083\n      853.100710\n      AFG\n      4\n    \n    \n      3\n      Afghanistan\n      Asia\n      1967\n      34.020\n      11537966\n      836.197138\n      AFG\n      4\n    \n    \n      4\n      Afghanistan\n      Asia\n      1972\n      36.088\n      13079460\n      739.981106\n      AFG\n      4\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      1675\n      Yemen, Rep.\n      Asia\n      1987\n      52.922\n      11219340\n      1971.741538\n      YEM\n      887\n    \n    \n      1676\n      Yemen, Rep.\n      Asia\n      1992\n      55.599\n      13367997\n      1879.496673\n      YEM\n      887\n    \n    \n      1677\n      Yemen, Rep.\n      Asia\n      1997\n      58.020\n      15826497\n      2117.484526\n      YEM\n      887\n    \n    \n      1678\n      Yemen, Rep.\n      Asia\n      2002\n      60.308\n      18701257\n      2234.820827\n      YEM\n      887\n    \n    \n      1679\n      Yemen, Rep.\n      Asia\n      2007\n      62.698\n      22211743\n      2280.769906\n      YEM\n      887\n    \n  \n\n396 rows × 8 columns\n\n\n\nquery함수로 continent가 Asia인 정보만 다시 표시합니다. 396개의 데이터로 줄었습니다.\n\nfig = px.line(df_asia, x='year', y='lifeExp', color='country')\nfig.show()\n\n\n                                                \n\n\n이 데이터를 Line Plot으로 표시합니다. x축을 year로 표시하고 y축을 기대수명을 나타내는 lifeExp로 표시합니다. 각 line의 색은 country에 따라 결정됩니다.\n아직 데이터가 많으니 평균기대수명보다 높고 1인당 GDP가 평균 이상인 국가만 다시 필터링하겠습니다.\n\nlifeExp_avg = df['lifeExp'].mean()\ngdpPercap_avg = df['gdpPercap'].mean()\ndisplay(lifeExp_avg)\ndf_result = df.query(\"continent == 'Asia' and lifeExp > @lifeExp_avg and gdpPercap > @gdpPercap_avg\")\ndf_result\n\n59.474439366197174\n\n\n\n\n\n\n  \n    \n      \n      country\n      continent\n      year\n      lifeExp\n      pop\n      gdpPercap\n      iso_alpha\n      iso_num\n    \n  \n  \n    \n      87\n      Bahrain\n      Asia\n      1967\n      59.923\n      202182\n      14804.672700\n      BHR\n      48\n    \n    \n      88\n      Bahrain\n      Asia\n      1972\n      63.300\n      230800\n      18268.658390\n      BHR\n      48\n    \n    \n      89\n      Bahrain\n      Asia\n      1977\n      65.593\n      297410\n      19340.101960\n      BHR\n      48\n    \n    \n      90\n      Bahrain\n      Asia\n      1982\n      69.052\n      377967\n      19211.147310\n      BHR\n      48\n    \n    \n      91\n      Bahrain\n      Asia\n      1987\n      70.750\n      454612\n      18524.024060\n      BHR\n      48\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      1508\n      Taiwan\n      Asia\n      1992\n      74.260\n      20686918\n      15215.657900\n      TWN\n      158\n    \n    \n      1509\n      Taiwan\n      Asia\n      1997\n      75.250\n      21628605\n      20206.820980\n      TWN\n      158\n    \n    \n      1510\n      Taiwan\n      Asia\n      2002\n      76.990\n      22454239\n      23235.423290\n      TWN\n      158\n    \n    \n      1511\n      Taiwan\n      Asia\n      2007\n      78.400\n      23174294\n      28718.276840\n      TWN\n      158\n    \n    \n      1535\n      Thailand\n      Asia\n      2007\n      70.616\n      65068149\n      7458.396327\n      THA\n      764\n    \n  \n\n95 rows × 8 columns\n\n\n\n\n\n이제 시점을 좀 더 확실히 보기 위해서 markers를 사용하여 마커를 적용합니다.\n\nfig = px.line(df_result, x='year', y='lifeExp', color='country', markers=True)\nfig.show()\n\n\n                                                \n\n\n각 라인에 서로다른 마커 심볼을 적용하기 위해서 symbol에 country정보를 전달합니다. 각 라인은 서로 다른 마커 심볼로 표시됩니다.\n\nfig = px.line(df_result, x='year', y='lifeExp', color='country', symbol='country', markers=True)\nfig.show()\n\n\n                                                \n\n\n\n\n\n날짜 정보를 갖는 데이터를 Line Plot으로 표시하는 방법을 정리합니다. stock()함수로 주식정보를 불러옵니다.\n\ndf = px.data.stocks()\ndf\n\n\n\n\n\n  \n    \n      \n      date\n      GOOG\n      AAPL\n      AMZN\n      FB\n      NFLX\n      MSFT\n    \n  \n  \n    \n      0\n      2018-01-01\n      1.000000\n      1.000000\n      1.000000\n      1.000000\n      1.000000\n      1.000000\n    \n    \n      1\n      2018-01-08\n      1.018172\n      1.011943\n      1.061881\n      0.959968\n      1.053526\n      1.015988\n    \n    \n      2\n      2018-01-15\n      1.032008\n      1.019771\n      1.053240\n      0.970243\n      1.049860\n      1.020524\n    \n    \n      3\n      2018-01-22\n      1.066783\n      0.980057\n      1.140676\n      1.016858\n      1.307681\n      1.066561\n    \n    \n      4\n      2018-01-29\n      1.008773\n      0.917143\n      1.163374\n      1.018357\n      1.273537\n      1.040708\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      100\n      2019-12-02\n      1.216280\n      1.546914\n      1.425061\n      1.075997\n      1.463641\n      1.720717\n    \n    \n      101\n      2019-12-09\n      1.222821\n      1.572286\n      1.432660\n      1.038855\n      1.421496\n      1.752239\n    \n    \n      102\n      2019-12-16\n      1.224418\n      1.596800\n      1.453455\n      1.104094\n      1.604362\n      1.784896\n    \n    \n      103\n      2019-12-23\n      1.226504\n      1.656000\n      1.521226\n      1.113728\n      1.567170\n      1.802472\n    \n    \n      104\n      2019-12-30\n      1.213014\n      1.678000\n      1.503360\n      1.098475\n      1.540883\n      1.788185\n    \n  \n\n105 rows × 7 columns\n\n\n\n데이터를 살펴보면 회사들의 주가를 시간에 따라서 저장하고 있습니다. y축에 표시할 데이터는 리스트 형태로 정보를 전달합니다. 마커사이즈는 marker_size를 이용해서 설정합니다.\n\nfig = px.line(df, x='date', y=[\"GOOG\", \"AAPL\", \"FB\"], markers=True)\nfig.update_traces(marker_size=10)\n\nfig.show()"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "온라인에 책을 만들고 싶다는 생각에 배운 것을 정리하는 사이트입니다. Quarto를 이용해서 만들었고 느리지만 꾸준이 업데이트하려고 노력하고 있습니다.\n궁금한 내용이나 함께 작성하고 싶은 책이 있다면 알려주세요. 감사합니다."
  }
]